// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: NetworkPacket.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "NetworkPacket.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace NetworkPacket {

void protobuf_ShutdownFile_NetworkPacket_2eproto() {
  delete KeepAliveInfo::default_instance_;
  delete UID::default_instance_;
  delete DeviceInfo::default_instance_;
  delete DeviceRunTimeInfo::default_instance_;
  delete LoginInfo::default_instance_;
  delete LogoutInfo::default_instance_;
  delete ThreadInfo::default_instance_;
  delete ThreadsInfo::default_instance_;
  delete LogStringInfo::default_instance_;
  delete TextureResInfo::default_instance_;
  delete TextureChangeSamplerFilter::default_instance_;
  delete DeviceTexResources::default_instance_;
  delete DeviceMemResInfo::default_instance_;
  delete DeviceMemResources::default_instance_;
  delete ShaderResInfo::default_instance_;
  delete DeviceShaderResources::default_instance_;
  delete GUIResInfo::default_instance_;
  delete PerformanceInfo::default_instance_;
  delete PerformanceParticlesInfo::default_instance_;
  delete PerformanceGlobalShaderInfo::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_NetworkPacket_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_NetworkPacket_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  KeepAliveInfo::default_instance_ = new KeepAliveInfo();
  UID::default_instance_ = new UID();
  DeviceInfo::default_instance_ = new DeviceInfo();
  DeviceRunTimeInfo::default_instance_ = new DeviceRunTimeInfo();
  LoginInfo::default_instance_ = new LoginInfo();
  LogoutInfo::default_instance_ = new LogoutInfo();
  ThreadInfo::default_instance_ = new ThreadInfo();
  ThreadsInfo::default_instance_ = new ThreadsInfo();
  LogStringInfo::default_instance_ = new LogStringInfo();
  TextureResInfo::default_instance_ = new TextureResInfo();
  TextureChangeSamplerFilter::default_instance_ = new TextureChangeSamplerFilter();
  DeviceTexResources::default_instance_ = new DeviceTexResources();
  DeviceMemResInfo::default_instance_ = new DeviceMemResInfo();
  DeviceMemResources::default_instance_ = new DeviceMemResources();
  ShaderResInfo::default_instance_ = new ShaderResInfo();
  DeviceShaderResources::default_instance_ = new DeviceShaderResources();
  GUIResInfo::default_instance_ = new GUIResInfo();
  PerformanceInfo::default_instance_ = new PerformanceInfo();
  PerformanceParticlesInfo::default_instance_ = new PerformanceParticlesInfo();
  PerformanceGlobalShaderInfo::default_instance_ = new PerformanceGlobalShaderInfo();
  KeepAliveInfo::default_instance_->InitAsDefaultInstance();
  UID::default_instance_->InitAsDefaultInstance();
  DeviceInfo::default_instance_->InitAsDefaultInstance();
  DeviceRunTimeInfo::default_instance_->InitAsDefaultInstance();
  LoginInfo::default_instance_->InitAsDefaultInstance();
  LogoutInfo::default_instance_->InitAsDefaultInstance();
  ThreadInfo::default_instance_->InitAsDefaultInstance();
  ThreadsInfo::default_instance_->InitAsDefaultInstance();
  LogStringInfo::default_instance_->InitAsDefaultInstance();
  TextureResInfo::default_instance_->InitAsDefaultInstance();
  TextureChangeSamplerFilter::default_instance_->InitAsDefaultInstance();
  DeviceTexResources::default_instance_->InitAsDefaultInstance();
  DeviceMemResInfo::default_instance_->InitAsDefaultInstance();
  DeviceMemResources::default_instance_->InitAsDefaultInstance();
  ShaderResInfo::default_instance_->InitAsDefaultInstance();
  DeviceShaderResources::default_instance_->InitAsDefaultInstance();
  GUIResInfo::default_instance_->InitAsDefaultInstance();
  PerformanceInfo::default_instance_->InitAsDefaultInstance();
  PerformanceParticlesInfo::default_instance_->InitAsDefaultInstance();
  PerformanceGlobalShaderInfo::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_NetworkPacket_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_NetworkPacket_2eproto_once_);
void protobuf_AddDesc_NetworkPacket_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_NetworkPacket_2eproto_once_,
                 &protobuf_AddDesc_NetworkPacket_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_NetworkPacket_2eproto {
  StaticDescriptorInitializer_NetworkPacket_2eproto() {
    protobuf_AddDesc_NetworkPacket_2eproto();
  }
} static_descriptor_initializer_NetworkPacket_2eproto_;
#endif
bool Constant_IsValid(int value) {
  switch(value) {
    case 60000:
      return true;
    default:
      return false;
  }
}

bool MessageType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 100:
    case 101:
    case 200:
    case 201:
    case 300:
    case 301:
    case 310:
    case 311:
    case 400:
    case 500:
    case 600:
    case 601:
    case 602:
      return true;
    default:
      return false;
  }
}

bool TextureType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

bool SamplerType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}


namespace {

static void MergeFromFail(int line) GOOGLE_ATTRIBUTE_COLD;
static void MergeFromFail(int line) {
  GOOGLE_CHECK(false) << __FILE__ << ":" << line;
}

}  // namespace


// ===================================================================

static ::std::string* MutableUnknownFieldsForKeepAliveInfo(
    KeepAliveInfo* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int KeepAliveInfo::kNumberFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

KeepAliveInfo::KeepAliveInfo()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:NetworkPacket.KeepAliveInfo)
}

void KeepAliveInfo::InitAsDefaultInstance() {
}

KeepAliveInfo::KeepAliveInfo(const KeepAliveInfo& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:NetworkPacket.KeepAliveInfo)
}

void KeepAliveInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  number_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

KeepAliveInfo::~KeepAliveInfo() {
  // @@protoc_insertion_point(destructor:NetworkPacket.KeepAliveInfo)
  SharedDtor();
}

void KeepAliveInfo::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void KeepAliveInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const KeepAliveInfo& KeepAliveInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_NetworkPacket_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_NetworkPacket_2eproto();
#endif
  return *default_instance_;
}

KeepAliveInfo* KeepAliveInfo::default_instance_ = NULL;

KeepAliveInfo* KeepAliveInfo::New(::google::protobuf::Arena* arena) const {
  KeepAliveInfo* n = new KeepAliveInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void KeepAliveInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:NetworkPacket.KeepAliveInfo)
  number_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool KeepAliveInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForKeepAliveInfo, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:NetworkPacket.KeepAliveInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 number = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &number_)));
          set_has_number();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:NetworkPacket.KeepAliveInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:NetworkPacket.KeepAliveInfo)
  return false;
#undef DO_
}

void KeepAliveInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:NetworkPacket.KeepAliveInfo)
  // required uint32 number = 1;
  if (has_number()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->number(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:NetworkPacket.KeepAliveInfo)
}

int KeepAliveInfo::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:NetworkPacket.KeepAliveInfo)
  int total_size = 0;

  // required uint32 number = 1;
  if (has_number()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->number());
  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void KeepAliveInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const KeepAliveInfo*>(&from));
}

void KeepAliveInfo::MergeFrom(const KeepAliveInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:NetworkPacket.KeepAliveInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_number()) {
      set_number(from.number());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void KeepAliveInfo::CopyFrom(const KeepAliveInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NetworkPacket.KeepAliveInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KeepAliveInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void KeepAliveInfo::Swap(KeepAliveInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void KeepAliveInfo::InternalSwap(KeepAliveInfo* other) {
  std::swap(number_, other->number_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string KeepAliveInfo::GetTypeName() const {
  return "NetworkPacket.KeepAliveInfo";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// KeepAliveInfo

// required uint32 number = 1;
bool KeepAliveInfo::has_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void KeepAliveInfo::set_has_number() {
  _has_bits_[0] |= 0x00000001u;
}
void KeepAliveInfo::clear_has_number() {
  _has_bits_[0] &= ~0x00000001u;
}
void KeepAliveInfo::clear_number() {
  number_ = 0u;
  clear_has_number();
}
 ::google::protobuf::uint32 KeepAliveInfo::number() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.KeepAliveInfo.number)
  return number_;
}
 void KeepAliveInfo::set_number(::google::protobuf::uint32 value) {
  set_has_number();
  number_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.KeepAliveInfo.number)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForUID(
    UID* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int UID::kData1FieldNumber;
const int UID::kData2FieldNumber;
const int UID::kData3FieldNumber;
const int UID::kData4FieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

UID::UID()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:NetworkPacket.UID)
}

void UID::InitAsDefaultInstance() {
}

UID::UID(const UID& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:NetworkPacket.UID)
}

void UID::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  data1_ = 0u;
  data2_ = 0u;
  data3_ = 0u;
  data4_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UID::~UID() {
  // @@protoc_insertion_point(destructor:NetworkPacket.UID)
  SharedDtor();
}

void UID::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void UID::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UID& UID::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_NetworkPacket_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_NetworkPacket_2eproto();
#endif
  return *default_instance_;
}

UID* UID::default_instance_ = NULL;

UID* UID::New(::google::protobuf::Arena* arena) const {
  UID* n = new UID;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void UID::Clear() {
// @@protoc_insertion_point(message_clear_start:NetworkPacket.UID)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(UID, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<UID*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(data1_, data4_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool UID::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForUID, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:NetworkPacket.UID)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 data1 = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &data1_)));
          set_has_data1();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_data2;
        break;
      }

      // required uint32 data2 = 2;
      case 2: {
        if (tag == 16) {
         parse_data2:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &data2_)));
          set_has_data2();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_data3;
        break;
      }

      // required uint32 data3 = 3;
      case 3: {
        if (tag == 24) {
         parse_data3:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &data3_)));
          set_has_data3();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_data4;
        break;
      }

      // required uint32 data4 = 4;
      case 4: {
        if (tag == 32) {
         parse_data4:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &data4_)));
          set_has_data4();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:NetworkPacket.UID)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:NetworkPacket.UID)
  return false;
#undef DO_
}

void UID::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:NetworkPacket.UID)
  // required uint32 data1 = 1;
  if (has_data1()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->data1(), output);
  }

  // required uint32 data2 = 2;
  if (has_data2()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->data2(), output);
  }

  // required uint32 data3 = 3;
  if (has_data3()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->data3(), output);
  }

  // required uint32 data4 = 4;
  if (has_data4()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->data4(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:NetworkPacket.UID)
}

int UID::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:NetworkPacket.UID)
  int total_size = 0;

  if (has_data1()) {
    // required uint32 data1 = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->data1());
  }

  if (has_data2()) {
    // required uint32 data2 = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->data2());
  }

  if (has_data3()) {
    // required uint32 data3 = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->data3());
  }

  if (has_data4()) {
    // required uint32 data4 = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->data4());
  }

  return total_size;
}
int UID::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:NetworkPacket.UID)
  int total_size = 0;

  if (((_has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required uint32 data1 = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->data1());

    // required uint32 data2 = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->data2());

    // required uint32 data3 = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->data3());

    // required uint32 data4 = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->data4());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UID::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UID*>(&from));
}

void UID::MergeFrom(const UID& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:NetworkPacket.UID)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_data1()) {
      set_data1(from.data1());
    }
    if (from.has_data2()) {
      set_data2(from.data2());
    }
    if (from.has_data3()) {
      set_data3(from.data3());
    }
    if (from.has_data4()) {
      set_data4(from.data4());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void UID::CopyFrom(const UID& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NetworkPacket.UID)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UID::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void UID::Swap(UID* other) {
  if (other == this) return;
  InternalSwap(other);
}
void UID::InternalSwap(UID* other) {
  std::swap(data1_, other->data1_);
  std::swap(data2_, other->data2_);
  std::swap(data3_, other->data3_);
  std::swap(data4_, other->data4_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string UID::GetTypeName() const {
  return "NetworkPacket.UID";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// UID

// required uint32 data1 = 1;
bool UID::has_data1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void UID::set_has_data1() {
  _has_bits_[0] |= 0x00000001u;
}
void UID::clear_has_data1() {
  _has_bits_[0] &= ~0x00000001u;
}
void UID::clear_data1() {
  data1_ = 0u;
  clear_has_data1();
}
 ::google::protobuf::uint32 UID::data1() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.UID.data1)
  return data1_;
}
 void UID::set_data1(::google::protobuf::uint32 value) {
  set_has_data1();
  data1_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.UID.data1)
}

// required uint32 data2 = 2;
bool UID::has_data2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void UID::set_has_data2() {
  _has_bits_[0] |= 0x00000002u;
}
void UID::clear_has_data2() {
  _has_bits_[0] &= ~0x00000002u;
}
void UID::clear_data2() {
  data2_ = 0u;
  clear_has_data2();
}
 ::google::protobuf::uint32 UID::data2() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.UID.data2)
  return data2_;
}
 void UID::set_data2(::google::protobuf::uint32 value) {
  set_has_data2();
  data2_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.UID.data2)
}

// required uint32 data3 = 3;
bool UID::has_data3() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void UID::set_has_data3() {
  _has_bits_[0] |= 0x00000004u;
}
void UID::clear_has_data3() {
  _has_bits_[0] &= ~0x00000004u;
}
void UID::clear_data3() {
  data3_ = 0u;
  clear_has_data3();
}
 ::google::protobuf::uint32 UID::data3() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.UID.data3)
  return data3_;
}
 void UID::set_data3(::google::protobuf::uint32 value) {
  set_has_data3();
  data3_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.UID.data3)
}

// required uint32 data4 = 4;
bool UID::has_data4() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void UID::set_has_data4() {
  _has_bits_[0] |= 0x00000008u;
}
void UID::clear_has_data4() {
  _has_bits_[0] &= ~0x00000008u;
}
void UID::clear_data4() {
  data4_ = 0u;
  clear_has_data4();
}
 ::google::protobuf::uint32 UID::data4() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.UID.data4)
  return data4_;
}
 void UID::set_data4(::google::protobuf::uint32 value) {
  set_has_data4();
  data4_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.UID.data4)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForDeviceInfo(
    DeviceInfo* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int DeviceInfo::kUidFieldNumber;
const int DeviceInfo::kProcessIdFieldNumber;
const int DeviceInfo::kBrandNameFieldNumber;
const int DeviceInfo::kDeviceNameFieldNumber;
const int DeviceInfo::kCpuNameFieldNumber;
const int DeviceInfo::kCpuCoreNumberFieldNumber;
const int DeviceInfo::kGpuNameFieldNumber;
const int DeviceInfo::kGpuCoreNumberFieldNumber;
const int DeviceInfo::kSmemSizeFieldNumber;
const int DeviceInfo::kVmemSizeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

DeviceInfo::DeviceInfo()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:NetworkPacket.DeviceInfo)
}

void DeviceInfo::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  uid_ = const_cast< ::NetworkPacket::UID*>(
      ::NetworkPacket::UID::internal_default_instance());
#else
  uid_ = const_cast< ::NetworkPacket::UID*>(&::NetworkPacket::UID::default_instance());
#endif
}

DeviceInfo::DeviceInfo(const DeviceInfo& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:NetworkPacket.DeviceInfo)
}

void DeviceInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  uid_ = NULL;
  process_id_ = 0u;
  brand_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  device_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  cpu_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  cpu_core_number_ = 0u;
  gpu_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  gpu_core_number_ = 0u;
  smem_size_ = GOOGLE_ULONGLONG(0);
  vmem_size_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DeviceInfo::~DeviceInfo() {
  // @@protoc_insertion_point(destructor:NetworkPacket.DeviceInfo)
  SharedDtor();
}

void DeviceInfo::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  brand_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  device_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  cpu_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  gpu_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete uid_;
  }
}

void DeviceInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DeviceInfo& DeviceInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_NetworkPacket_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_NetworkPacket_2eproto();
#endif
  return *default_instance_;
}

DeviceInfo* DeviceInfo::default_instance_ = NULL;

DeviceInfo* DeviceInfo::New(::google::protobuf::Arena* arena) const {
  DeviceInfo* n = new DeviceInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void DeviceInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:NetworkPacket.DeviceInfo)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(DeviceInfo, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<DeviceInfo*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 255u) {
    ZR_(process_id_, cpu_core_number_);
    if (has_uid()) {
      if (uid_ != NULL) uid_->::NetworkPacket::UID::Clear();
    }
    if (has_brand_name()) {
      brand_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_device_name()) {
      device_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_cpu_name()) {
      cpu_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_gpu_name()) {
      gpu_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    gpu_core_number_ = 0u;
  }
  ZR_(smem_size_, vmem_size_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool DeviceInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForDeviceInfo, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:NetworkPacket.DeviceInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .NetworkPacket.UID uid = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_uid()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_process_id;
        break;
      }

      // required uint32 process_id = 2;
      case 2: {
        if (tag == 16) {
         parse_process_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &process_id_)));
          set_has_process_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_brand_name;
        break;
      }

      // required string brand_name = 3;
      case 3: {
        if (tag == 26) {
         parse_brand_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_brand_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_device_name;
        break;
      }

      // required string device_name = 4;
      case 4: {
        if (tag == 34) {
         parse_device_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_device_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_cpu_name;
        break;
      }

      // required string cpu_name = 5;
      case 5: {
        if (tag == 42) {
         parse_cpu_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_cpu_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_cpu_core_number;
        break;
      }

      // required uint32 cpu_core_number = 6;
      case 6: {
        if (tag == 48) {
         parse_cpu_core_number:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &cpu_core_number_)));
          set_has_cpu_core_number();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_gpu_name;
        break;
      }

      // required string gpu_name = 7;
      case 7: {
        if (tag == 58) {
         parse_gpu_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_gpu_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_gpu_core_number;
        break;
      }

      // required uint32 gpu_core_number = 8;
      case 8: {
        if (tag == 64) {
         parse_gpu_core_number:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &gpu_core_number_)));
          set_has_gpu_core_number();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_smem_size;
        break;
      }

      // required uint64 smem_size = 9;
      case 9: {
        if (tag == 72) {
         parse_smem_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &smem_size_)));
          set_has_smem_size();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_vmem_size;
        break;
      }

      // required uint64 vmem_size = 10;
      case 10: {
        if (tag == 80) {
         parse_vmem_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &vmem_size_)));
          set_has_vmem_size();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:NetworkPacket.DeviceInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:NetworkPacket.DeviceInfo)
  return false;
#undef DO_
}

void DeviceInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:NetworkPacket.DeviceInfo)
  // required .NetworkPacket.UID uid = 1;
  if (has_uid()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->uid_, output);
  }

  // required uint32 process_id = 2;
  if (has_process_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->process_id(), output);
  }

  // required string brand_name = 3;
  if (has_brand_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->brand_name(), output);
  }

  // required string device_name = 4;
  if (has_device_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->device_name(), output);
  }

  // required string cpu_name = 5;
  if (has_cpu_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->cpu_name(), output);
  }

  // required uint32 cpu_core_number = 6;
  if (has_cpu_core_number()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->cpu_core_number(), output);
  }

  // required string gpu_name = 7;
  if (has_gpu_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      7, this->gpu_name(), output);
  }

  // required uint32 gpu_core_number = 8;
  if (has_gpu_core_number()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->gpu_core_number(), output);
  }

  // required uint64 smem_size = 9;
  if (has_smem_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(9, this->smem_size(), output);
  }

  // required uint64 vmem_size = 10;
  if (has_vmem_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(10, this->vmem_size(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:NetworkPacket.DeviceInfo)
}

int DeviceInfo::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:NetworkPacket.DeviceInfo)
  int total_size = 0;

  if (has_uid()) {
    // required .NetworkPacket.UID uid = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->uid_);
  }

  if (has_process_id()) {
    // required uint32 process_id = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->process_id());
  }

  if (has_brand_name()) {
    // required string brand_name = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->brand_name());
  }

  if (has_device_name()) {
    // required string device_name = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->device_name());
  }

  if (has_cpu_name()) {
    // required string cpu_name = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->cpu_name());
  }

  if (has_cpu_core_number()) {
    // required uint32 cpu_core_number = 6;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->cpu_core_number());
  }

  if (has_gpu_name()) {
    // required string gpu_name = 7;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->gpu_name());
  }

  if (has_gpu_core_number()) {
    // required uint32 gpu_core_number = 8;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->gpu_core_number());
  }

  if (has_smem_size()) {
    // required uint64 smem_size = 9;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->smem_size());
  }

  if (has_vmem_size()) {
    // required uint64 vmem_size = 10;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->vmem_size());
  }

  return total_size;
}
int DeviceInfo::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:NetworkPacket.DeviceInfo)
  int total_size = 0;

  if (((_has_bits_[0] & 0x000003ff) ^ 0x000003ff) == 0) {  // All required fields are present.
    // required .NetworkPacket.UID uid = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->uid_);

    // required uint32 process_id = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->process_id());

    // required string brand_name = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->brand_name());

    // required string device_name = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->device_name());

    // required string cpu_name = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->cpu_name());

    // required uint32 cpu_core_number = 6;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->cpu_core_number());

    // required string gpu_name = 7;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->gpu_name());

    // required uint32 gpu_core_number = 8;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->gpu_core_number());

    // required uint64 smem_size = 9;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->smem_size());

    // required uint64 vmem_size = 10;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->vmem_size());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DeviceInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DeviceInfo*>(&from));
}

void DeviceInfo::MergeFrom(const DeviceInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:NetworkPacket.DeviceInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uid()) {
      mutable_uid()->::NetworkPacket::UID::MergeFrom(from.uid());
    }
    if (from.has_process_id()) {
      set_process_id(from.process_id());
    }
    if (from.has_brand_name()) {
      set_has_brand_name();
      brand_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.brand_name_);
    }
    if (from.has_device_name()) {
      set_has_device_name();
      device_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.device_name_);
    }
    if (from.has_cpu_name()) {
      set_has_cpu_name();
      cpu_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.cpu_name_);
    }
    if (from.has_cpu_core_number()) {
      set_cpu_core_number(from.cpu_core_number());
    }
    if (from.has_gpu_name()) {
      set_has_gpu_name();
      gpu_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.gpu_name_);
    }
    if (from.has_gpu_core_number()) {
      set_gpu_core_number(from.gpu_core_number());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_smem_size()) {
      set_smem_size(from.smem_size());
    }
    if (from.has_vmem_size()) {
      set_vmem_size(from.vmem_size());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void DeviceInfo::CopyFrom(const DeviceInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NetworkPacket.DeviceInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x000003ff) != 0x000003ff) return false;

  if (has_uid()) {
    if (!this->uid_->IsInitialized()) return false;
  }
  return true;
}

void DeviceInfo::Swap(DeviceInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DeviceInfo::InternalSwap(DeviceInfo* other) {
  std::swap(uid_, other->uid_);
  std::swap(process_id_, other->process_id_);
  brand_name_.Swap(&other->brand_name_);
  device_name_.Swap(&other->device_name_);
  cpu_name_.Swap(&other->cpu_name_);
  std::swap(cpu_core_number_, other->cpu_core_number_);
  gpu_name_.Swap(&other->gpu_name_);
  std::swap(gpu_core_number_, other->gpu_core_number_);
  std::swap(smem_size_, other->smem_size_);
  std::swap(vmem_size_, other->vmem_size_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string DeviceInfo::GetTypeName() const {
  return "NetworkPacket.DeviceInfo";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// DeviceInfo

// required .NetworkPacket.UID uid = 1;
bool DeviceInfo::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void DeviceInfo::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
void DeviceInfo::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
void DeviceInfo::clear_uid() {
  if (uid_ != NULL) uid_->::NetworkPacket::UID::Clear();
  clear_has_uid();
}
const ::NetworkPacket::UID& DeviceInfo::uid() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.DeviceInfo.uid)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return uid_ != NULL ? *uid_ : *default_instance().uid_;
#else
  return uid_ != NULL ? *uid_ : *default_instance_->uid_;
#endif
}
::NetworkPacket::UID* DeviceInfo::mutable_uid() {
  set_has_uid();
  if (uid_ == NULL) {
    uid_ = new ::NetworkPacket::UID;
  }
  // @@protoc_insertion_point(field_mutable:NetworkPacket.DeviceInfo.uid)
  return uid_;
}
::NetworkPacket::UID* DeviceInfo::release_uid() {
  // @@protoc_insertion_point(field_release:NetworkPacket.DeviceInfo.uid)
  clear_has_uid();
  ::NetworkPacket::UID* temp = uid_;
  uid_ = NULL;
  return temp;
}
void DeviceInfo::set_allocated_uid(::NetworkPacket::UID* uid) {
  delete uid_;
  uid_ = uid;
  if (uid) {
    set_has_uid();
  } else {
    clear_has_uid();
  }
  // @@protoc_insertion_point(field_set_allocated:NetworkPacket.DeviceInfo.uid)
}

// required uint32 process_id = 2;
bool DeviceInfo::has_process_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void DeviceInfo::set_has_process_id() {
  _has_bits_[0] |= 0x00000002u;
}
void DeviceInfo::clear_has_process_id() {
  _has_bits_[0] &= ~0x00000002u;
}
void DeviceInfo::clear_process_id() {
  process_id_ = 0u;
  clear_has_process_id();
}
 ::google::protobuf::uint32 DeviceInfo::process_id() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.DeviceInfo.process_id)
  return process_id_;
}
 void DeviceInfo::set_process_id(::google::protobuf::uint32 value) {
  set_has_process_id();
  process_id_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.DeviceInfo.process_id)
}

// required string brand_name = 3;
bool DeviceInfo::has_brand_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void DeviceInfo::set_has_brand_name() {
  _has_bits_[0] |= 0x00000004u;
}
void DeviceInfo::clear_has_brand_name() {
  _has_bits_[0] &= ~0x00000004u;
}
void DeviceInfo::clear_brand_name() {
  brand_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_brand_name();
}
 const ::std::string& DeviceInfo::brand_name() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.DeviceInfo.brand_name)
  return brand_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void DeviceInfo::set_brand_name(const ::std::string& value) {
  set_has_brand_name();
  brand_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NetworkPacket.DeviceInfo.brand_name)
}
 void DeviceInfo::set_brand_name(const char* value) {
  set_has_brand_name();
  brand_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NetworkPacket.DeviceInfo.brand_name)
}
 void DeviceInfo::set_brand_name(const char* value, size_t size) {
  set_has_brand_name();
  brand_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NetworkPacket.DeviceInfo.brand_name)
}
 ::std::string* DeviceInfo::mutable_brand_name() {
  set_has_brand_name();
  // @@protoc_insertion_point(field_mutable:NetworkPacket.DeviceInfo.brand_name)
  return brand_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* DeviceInfo::release_brand_name() {
  // @@protoc_insertion_point(field_release:NetworkPacket.DeviceInfo.brand_name)
  clear_has_brand_name();
  return brand_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void DeviceInfo::set_allocated_brand_name(::std::string* brand_name) {
  if (brand_name != NULL) {
    set_has_brand_name();
  } else {
    clear_has_brand_name();
  }
  brand_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), brand_name);
  // @@protoc_insertion_point(field_set_allocated:NetworkPacket.DeviceInfo.brand_name)
}

// required string device_name = 4;
bool DeviceInfo::has_device_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void DeviceInfo::set_has_device_name() {
  _has_bits_[0] |= 0x00000008u;
}
void DeviceInfo::clear_has_device_name() {
  _has_bits_[0] &= ~0x00000008u;
}
void DeviceInfo::clear_device_name() {
  device_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_device_name();
}
 const ::std::string& DeviceInfo::device_name() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.DeviceInfo.device_name)
  return device_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void DeviceInfo::set_device_name(const ::std::string& value) {
  set_has_device_name();
  device_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NetworkPacket.DeviceInfo.device_name)
}
 void DeviceInfo::set_device_name(const char* value) {
  set_has_device_name();
  device_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NetworkPacket.DeviceInfo.device_name)
}
 void DeviceInfo::set_device_name(const char* value, size_t size) {
  set_has_device_name();
  device_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NetworkPacket.DeviceInfo.device_name)
}
 ::std::string* DeviceInfo::mutable_device_name() {
  set_has_device_name();
  // @@protoc_insertion_point(field_mutable:NetworkPacket.DeviceInfo.device_name)
  return device_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* DeviceInfo::release_device_name() {
  // @@protoc_insertion_point(field_release:NetworkPacket.DeviceInfo.device_name)
  clear_has_device_name();
  return device_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void DeviceInfo::set_allocated_device_name(::std::string* device_name) {
  if (device_name != NULL) {
    set_has_device_name();
  } else {
    clear_has_device_name();
  }
  device_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), device_name);
  // @@protoc_insertion_point(field_set_allocated:NetworkPacket.DeviceInfo.device_name)
}

// required string cpu_name = 5;
bool DeviceInfo::has_cpu_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void DeviceInfo::set_has_cpu_name() {
  _has_bits_[0] |= 0x00000010u;
}
void DeviceInfo::clear_has_cpu_name() {
  _has_bits_[0] &= ~0x00000010u;
}
void DeviceInfo::clear_cpu_name() {
  cpu_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_cpu_name();
}
 const ::std::string& DeviceInfo::cpu_name() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.DeviceInfo.cpu_name)
  return cpu_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void DeviceInfo::set_cpu_name(const ::std::string& value) {
  set_has_cpu_name();
  cpu_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NetworkPacket.DeviceInfo.cpu_name)
}
 void DeviceInfo::set_cpu_name(const char* value) {
  set_has_cpu_name();
  cpu_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NetworkPacket.DeviceInfo.cpu_name)
}
 void DeviceInfo::set_cpu_name(const char* value, size_t size) {
  set_has_cpu_name();
  cpu_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NetworkPacket.DeviceInfo.cpu_name)
}
 ::std::string* DeviceInfo::mutable_cpu_name() {
  set_has_cpu_name();
  // @@protoc_insertion_point(field_mutable:NetworkPacket.DeviceInfo.cpu_name)
  return cpu_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* DeviceInfo::release_cpu_name() {
  // @@protoc_insertion_point(field_release:NetworkPacket.DeviceInfo.cpu_name)
  clear_has_cpu_name();
  return cpu_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void DeviceInfo::set_allocated_cpu_name(::std::string* cpu_name) {
  if (cpu_name != NULL) {
    set_has_cpu_name();
  } else {
    clear_has_cpu_name();
  }
  cpu_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cpu_name);
  // @@protoc_insertion_point(field_set_allocated:NetworkPacket.DeviceInfo.cpu_name)
}

// required uint32 cpu_core_number = 6;
bool DeviceInfo::has_cpu_core_number() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void DeviceInfo::set_has_cpu_core_number() {
  _has_bits_[0] |= 0x00000020u;
}
void DeviceInfo::clear_has_cpu_core_number() {
  _has_bits_[0] &= ~0x00000020u;
}
void DeviceInfo::clear_cpu_core_number() {
  cpu_core_number_ = 0u;
  clear_has_cpu_core_number();
}
 ::google::protobuf::uint32 DeviceInfo::cpu_core_number() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.DeviceInfo.cpu_core_number)
  return cpu_core_number_;
}
 void DeviceInfo::set_cpu_core_number(::google::protobuf::uint32 value) {
  set_has_cpu_core_number();
  cpu_core_number_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.DeviceInfo.cpu_core_number)
}

// required string gpu_name = 7;
bool DeviceInfo::has_gpu_name() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void DeviceInfo::set_has_gpu_name() {
  _has_bits_[0] |= 0x00000040u;
}
void DeviceInfo::clear_has_gpu_name() {
  _has_bits_[0] &= ~0x00000040u;
}
void DeviceInfo::clear_gpu_name() {
  gpu_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_gpu_name();
}
 const ::std::string& DeviceInfo::gpu_name() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.DeviceInfo.gpu_name)
  return gpu_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void DeviceInfo::set_gpu_name(const ::std::string& value) {
  set_has_gpu_name();
  gpu_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NetworkPacket.DeviceInfo.gpu_name)
}
 void DeviceInfo::set_gpu_name(const char* value) {
  set_has_gpu_name();
  gpu_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NetworkPacket.DeviceInfo.gpu_name)
}
 void DeviceInfo::set_gpu_name(const char* value, size_t size) {
  set_has_gpu_name();
  gpu_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NetworkPacket.DeviceInfo.gpu_name)
}
 ::std::string* DeviceInfo::mutable_gpu_name() {
  set_has_gpu_name();
  // @@protoc_insertion_point(field_mutable:NetworkPacket.DeviceInfo.gpu_name)
  return gpu_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* DeviceInfo::release_gpu_name() {
  // @@protoc_insertion_point(field_release:NetworkPacket.DeviceInfo.gpu_name)
  clear_has_gpu_name();
  return gpu_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void DeviceInfo::set_allocated_gpu_name(::std::string* gpu_name) {
  if (gpu_name != NULL) {
    set_has_gpu_name();
  } else {
    clear_has_gpu_name();
  }
  gpu_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), gpu_name);
  // @@protoc_insertion_point(field_set_allocated:NetworkPacket.DeviceInfo.gpu_name)
}

// required uint32 gpu_core_number = 8;
bool DeviceInfo::has_gpu_core_number() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void DeviceInfo::set_has_gpu_core_number() {
  _has_bits_[0] |= 0x00000080u;
}
void DeviceInfo::clear_has_gpu_core_number() {
  _has_bits_[0] &= ~0x00000080u;
}
void DeviceInfo::clear_gpu_core_number() {
  gpu_core_number_ = 0u;
  clear_has_gpu_core_number();
}
 ::google::protobuf::uint32 DeviceInfo::gpu_core_number() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.DeviceInfo.gpu_core_number)
  return gpu_core_number_;
}
 void DeviceInfo::set_gpu_core_number(::google::protobuf::uint32 value) {
  set_has_gpu_core_number();
  gpu_core_number_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.DeviceInfo.gpu_core_number)
}

// required uint64 smem_size = 9;
bool DeviceInfo::has_smem_size() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void DeviceInfo::set_has_smem_size() {
  _has_bits_[0] |= 0x00000100u;
}
void DeviceInfo::clear_has_smem_size() {
  _has_bits_[0] &= ~0x00000100u;
}
void DeviceInfo::clear_smem_size() {
  smem_size_ = GOOGLE_ULONGLONG(0);
  clear_has_smem_size();
}
 ::google::protobuf::uint64 DeviceInfo::smem_size() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.DeviceInfo.smem_size)
  return smem_size_;
}
 void DeviceInfo::set_smem_size(::google::protobuf::uint64 value) {
  set_has_smem_size();
  smem_size_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.DeviceInfo.smem_size)
}

// required uint64 vmem_size = 10;
bool DeviceInfo::has_vmem_size() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
void DeviceInfo::set_has_vmem_size() {
  _has_bits_[0] |= 0x00000200u;
}
void DeviceInfo::clear_has_vmem_size() {
  _has_bits_[0] &= ~0x00000200u;
}
void DeviceInfo::clear_vmem_size() {
  vmem_size_ = GOOGLE_ULONGLONG(0);
  clear_has_vmem_size();
}
 ::google::protobuf::uint64 DeviceInfo::vmem_size() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.DeviceInfo.vmem_size)
  return vmem_size_;
}
 void DeviceInfo::set_vmem_size(::google::protobuf::uint64 value) {
  set_has_vmem_size();
  vmem_size_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.DeviceInfo.vmem_size)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForDeviceRunTimeInfo(
    DeviceRunTimeInfo* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int DeviceRunTimeInfo::kUidFieldNumber;
const int DeviceRunTimeInfo::kFpsFieldNumber;
const int DeviceRunTimeInfo::kSmemSizeFieldNumber;
const int DeviceRunTimeInfo::kVmemSizeFieldNumber;
const int DeviceRunTimeInfo::kCpuUsageFieldNumber;
const int DeviceRunTimeInfo::kGpuUsageFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

DeviceRunTimeInfo::DeviceRunTimeInfo()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:NetworkPacket.DeviceRunTimeInfo)
}

void DeviceRunTimeInfo::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  uid_ = const_cast< ::NetworkPacket::UID*>(
      ::NetworkPacket::UID::internal_default_instance());
#else
  uid_ = const_cast< ::NetworkPacket::UID*>(&::NetworkPacket::UID::default_instance());
#endif
}

DeviceRunTimeInfo::DeviceRunTimeInfo(const DeviceRunTimeInfo& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:NetworkPacket.DeviceRunTimeInfo)
}

void DeviceRunTimeInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  uid_ = NULL;
  fps_ = 0;
  smem_size_ = GOOGLE_ULONGLONG(0);
  vmem_size_ = GOOGLE_ULONGLONG(0);
  cpu_usage_ = 0;
  gpu_usage_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DeviceRunTimeInfo::~DeviceRunTimeInfo() {
  // @@protoc_insertion_point(destructor:NetworkPacket.DeviceRunTimeInfo)
  SharedDtor();
}

void DeviceRunTimeInfo::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete uid_;
  }
}

void DeviceRunTimeInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DeviceRunTimeInfo& DeviceRunTimeInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_NetworkPacket_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_NetworkPacket_2eproto();
#endif
  return *default_instance_;
}

DeviceRunTimeInfo* DeviceRunTimeInfo::default_instance_ = NULL;

DeviceRunTimeInfo* DeviceRunTimeInfo::New(::google::protobuf::Arena* arena) const {
  DeviceRunTimeInfo* n = new DeviceRunTimeInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void DeviceRunTimeInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:NetworkPacket.DeviceRunTimeInfo)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(DeviceRunTimeInfo, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<DeviceRunTimeInfo*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 63u) {
    ZR_(smem_size_, gpu_usage_);
    if (has_uid()) {
      if (uid_ != NULL) uid_->::NetworkPacket::UID::Clear();
    }
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool DeviceRunTimeInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForDeviceRunTimeInfo, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:NetworkPacket.DeviceRunTimeInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .NetworkPacket.UID uid = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_uid()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_fps;
        break;
      }

      // required float fps = 2;
      case 2: {
        if (tag == 21) {
         parse_fps:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &fps_)));
          set_has_fps();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_smem_size;
        break;
      }

      // required uint64 smem_size = 3;
      case 3: {
        if (tag == 24) {
         parse_smem_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &smem_size_)));
          set_has_smem_size();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_vmem_size;
        break;
      }

      // required uint64 vmem_size = 4;
      case 4: {
        if (tag == 32) {
         parse_vmem_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &vmem_size_)));
          set_has_vmem_size();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(45)) goto parse_cpu_usage;
        break;
      }

      // required float cpu_usage = 5;
      case 5: {
        if (tag == 45) {
         parse_cpu_usage:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &cpu_usage_)));
          set_has_cpu_usage();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(53)) goto parse_gpu_usage;
        break;
      }

      // required float gpu_usage = 6;
      case 6: {
        if (tag == 53) {
         parse_gpu_usage:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &gpu_usage_)));
          set_has_gpu_usage();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:NetworkPacket.DeviceRunTimeInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:NetworkPacket.DeviceRunTimeInfo)
  return false;
#undef DO_
}

void DeviceRunTimeInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:NetworkPacket.DeviceRunTimeInfo)
  // required .NetworkPacket.UID uid = 1;
  if (has_uid()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->uid_, output);
  }

  // required float fps = 2;
  if (has_fps()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->fps(), output);
  }

  // required uint64 smem_size = 3;
  if (has_smem_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->smem_size(), output);
  }

  // required uint64 vmem_size = 4;
  if (has_vmem_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->vmem_size(), output);
  }

  // required float cpu_usage = 5;
  if (has_cpu_usage()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->cpu_usage(), output);
  }

  // required float gpu_usage = 6;
  if (has_gpu_usage()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(6, this->gpu_usage(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:NetworkPacket.DeviceRunTimeInfo)
}

int DeviceRunTimeInfo::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:NetworkPacket.DeviceRunTimeInfo)
  int total_size = 0;

  if (has_uid()) {
    // required .NetworkPacket.UID uid = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->uid_);
  }

  if (has_fps()) {
    // required float fps = 2;
    total_size += 1 + 4;
  }

  if (has_smem_size()) {
    // required uint64 smem_size = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->smem_size());
  }

  if (has_vmem_size()) {
    // required uint64 vmem_size = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->vmem_size());
  }

  if (has_cpu_usage()) {
    // required float cpu_usage = 5;
    total_size += 1 + 4;
  }

  if (has_gpu_usage()) {
    // required float gpu_usage = 6;
    total_size += 1 + 4;
  }

  return total_size;
}
int DeviceRunTimeInfo::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:NetworkPacket.DeviceRunTimeInfo)
  int total_size = 0;

  if (((_has_bits_[0] & 0x0000003f) ^ 0x0000003f) == 0) {  // All required fields are present.
    // required .NetworkPacket.UID uid = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->uid_);

    // required float fps = 2;
    total_size += 1 + 4;

    // required uint64 smem_size = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->smem_size());

    // required uint64 vmem_size = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->vmem_size());

    // required float cpu_usage = 5;
    total_size += 1 + 4;

    // required float gpu_usage = 6;
    total_size += 1 + 4;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DeviceRunTimeInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DeviceRunTimeInfo*>(&from));
}

void DeviceRunTimeInfo::MergeFrom(const DeviceRunTimeInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:NetworkPacket.DeviceRunTimeInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uid()) {
      mutable_uid()->::NetworkPacket::UID::MergeFrom(from.uid());
    }
    if (from.has_fps()) {
      set_fps(from.fps());
    }
    if (from.has_smem_size()) {
      set_smem_size(from.smem_size());
    }
    if (from.has_vmem_size()) {
      set_vmem_size(from.vmem_size());
    }
    if (from.has_cpu_usage()) {
      set_cpu_usage(from.cpu_usage());
    }
    if (from.has_gpu_usage()) {
      set_gpu_usage(from.gpu_usage());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void DeviceRunTimeInfo::CopyFrom(const DeviceRunTimeInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NetworkPacket.DeviceRunTimeInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceRunTimeInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;

  if (has_uid()) {
    if (!this->uid_->IsInitialized()) return false;
  }
  return true;
}

void DeviceRunTimeInfo::Swap(DeviceRunTimeInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DeviceRunTimeInfo::InternalSwap(DeviceRunTimeInfo* other) {
  std::swap(uid_, other->uid_);
  std::swap(fps_, other->fps_);
  std::swap(smem_size_, other->smem_size_);
  std::swap(vmem_size_, other->vmem_size_);
  std::swap(cpu_usage_, other->cpu_usage_);
  std::swap(gpu_usage_, other->gpu_usage_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string DeviceRunTimeInfo::GetTypeName() const {
  return "NetworkPacket.DeviceRunTimeInfo";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// DeviceRunTimeInfo

// required .NetworkPacket.UID uid = 1;
bool DeviceRunTimeInfo::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void DeviceRunTimeInfo::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
void DeviceRunTimeInfo::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
void DeviceRunTimeInfo::clear_uid() {
  if (uid_ != NULL) uid_->::NetworkPacket::UID::Clear();
  clear_has_uid();
}
const ::NetworkPacket::UID& DeviceRunTimeInfo::uid() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.DeviceRunTimeInfo.uid)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return uid_ != NULL ? *uid_ : *default_instance().uid_;
#else
  return uid_ != NULL ? *uid_ : *default_instance_->uid_;
#endif
}
::NetworkPacket::UID* DeviceRunTimeInfo::mutable_uid() {
  set_has_uid();
  if (uid_ == NULL) {
    uid_ = new ::NetworkPacket::UID;
  }
  // @@protoc_insertion_point(field_mutable:NetworkPacket.DeviceRunTimeInfo.uid)
  return uid_;
}
::NetworkPacket::UID* DeviceRunTimeInfo::release_uid() {
  // @@protoc_insertion_point(field_release:NetworkPacket.DeviceRunTimeInfo.uid)
  clear_has_uid();
  ::NetworkPacket::UID* temp = uid_;
  uid_ = NULL;
  return temp;
}
void DeviceRunTimeInfo::set_allocated_uid(::NetworkPacket::UID* uid) {
  delete uid_;
  uid_ = uid;
  if (uid) {
    set_has_uid();
  } else {
    clear_has_uid();
  }
  // @@protoc_insertion_point(field_set_allocated:NetworkPacket.DeviceRunTimeInfo.uid)
}

// required float fps = 2;
bool DeviceRunTimeInfo::has_fps() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void DeviceRunTimeInfo::set_has_fps() {
  _has_bits_[0] |= 0x00000002u;
}
void DeviceRunTimeInfo::clear_has_fps() {
  _has_bits_[0] &= ~0x00000002u;
}
void DeviceRunTimeInfo::clear_fps() {
  fps_ = 0;
  clear_has_fps();
}
 float DeviceRunTimeInfo::fps() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.DeviceRunTimeInfo.fps)
  return fps_;
}
 void DeviceRunTimeInfo::set_fps(float value) {
  set_has_fps();
  fps_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.DeviceRunTimeInfo.fps)
}

// required uint64 smem_size = 3;
bool DeviceRunTimeInfo::has_smem_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void DeviceRunTimeInfo::set_has_smem_size() {
  _has_bits_[0] |= 0x00000004u;
}
void DeviceRunTimeInfo::clear_has_smem_size() {
  _has_bits_[0] &= ~0x00000004u;
}
void DeviceRunTimeInfo::clear_smem_size() {
  smem_size_ = GOOGLE_ULONGLONG(0);
  clear_has_smem_size();
}
 ::google::protobuf::uint64 DeviceRunTimeInfo::smem_size() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.DeviceRunTimeInfo.smem_size)
  return smem_size_;
}
 void DeviceRunTimeInfo::set_smem_size(::google::protobuf::uint64 value) {
  set_has_smem_size();
  smem_size_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.DeviceRunTimeInfo.smem_size)
}

// required uint64 vmem_size = 4;
bool DeviceRunTimeInfo::has_vmem_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void DeviceRunTimeInfo::set_has_vmem_size() {
  _has_bits_[0] |= 0x00000008u;
}
void DeviceRunTimeInfo::clear_has_vmem_size() {
  _has_bits_[0] &= ~0x00000008u;
}
void DeviceRunTimeInfo::clear_vmem_size() {
  vmem_size_ = GOOGLE_ULONGLONG(0);
  clear_has_vmem_size();
}
 ::google::protobuf::uint64 DeviceRunTimeInfo::vmem_size() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.DeviceRunTimeInfo.vmem_size)
  return vmem_size_;
}
 void DeviceRunTimeInfo::set_vmem_size(::google::protobuf::uint64 value) {
  set_has_vmem_size();
  vmem_size_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.DeviceRunTimeInfo.vmem_size)
}

// required float cpu_usage = 5;
bool DeviceRunTimeInfo::has_cpu_usage() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void DeviceRunTimeInfo::set_has_cpu_usage() {
  _has_bits_[0] |= 0x00000010u;
}
void DeviceRunTimeInfo::clear_has_cpu_usage() {
  _has_bits_[0] &= ~0x00000010u;
}
void DeviceRunTimeInfo::clear_cpu_usage() {
  cpu_usage_ = 0;
  clear_has_cpu_usage();
}
 float DeviceRunTimeInfo::cpu_usage() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.DeviceRunTimeInfo.cpu_usage)
  return cpu_usage_;
}
 void DeviceRunTimeInfo::set_cpu_usage(float value) {
  set_has_cpu_usage();
  cpu_usage_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.DeviceRunTimeInfo.cpu_usage)
}

// required float gpu_usage = 6;
bool DeviceRunTimeInfo::has_gpu_usage() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void DeviceRunTimeInfo::set_has_gpu_usage() {
  _has_bits_[0] |= 0x00000020u;
}
void DeviceRunTimeInfo::clear_has_gpu_usage() {
  _has_bits_[0] &= ~0x00000020u;
}
void DeviceRunTimeInfo::clear_gpu_usage() {
  gpu_usage_ = 0;
  clear_has_gpu_usage();
}
 float DeviceRunTimeInfo::gpu_usage() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.DeviceRunTimeInfo.gpu_usage)
  return gpu_usage_;
}
 void DeviceRunTimeInfo::set_gpu_usage(float value) {
  set_has_gpu_usage();
  gpu_usage_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.DeviceRunTimeInfo.gpu_usage)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForLoginInfo(
    LoginInfo* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int LoginInfo::kDeviceFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

LoginInfo::LoginInfo()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:NetworkPacket.LoginInfo)
}

void LoginInfo::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  device_ = const_cast< ::NetworkPacket::DeviceInfo*>(
      ::NetworkPacket::DeviceInfo::internal_default_instance());
#else
  device_ = const_cast< ::NetworkPacket::DeviceInfo*>(&::NetworkPacket::DeviceInfo::default_instance());
#endif
}

LoginInfo::LoginInfo(const LoginInfo& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:NetworkPacket.LoginInfo)
}

void LoginInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  device_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LoginInfo::~LoginInfo() {
  // @@protoc_insertion_point(destructor:NetworkPacket.LoginInfo)
  SharedDtor();
}

void LoginInfo::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete device_;
  }
}

void LoginInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LoginInfo& LoginInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_NetworkPacket_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_NetworkPacket_2eproto();
#endif
  return *default_instance_;
}

LoginInfo* LoginInfo::default_instance_ = NULL;

LoginInfo* LoginInfo::New(::google::protobuf::Arena* arena) const {
  LoginInfo* n = new LoginInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void LoginInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:NetworkPacket.LoginInfo)
  if (has_device()) {
    if (device_ != NULL) device_->::NetworkPacket::DeviceInfo::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool LoginInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForLoginInfo, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:NetworkPacket.LoginInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .NetworkPacket.DeviceInfo device = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_device()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:NetworkPacket.LoginInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:NetworkPacket.LoginInfo)
  return false;
#undef DO_
}

void LoginInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:NetworkPacket.LoginInfo)
  // required .NetworkPacket.DeviceInfo device = 1;
  if (has_device()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->device_, output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:NetworkPacket.LoginInfo)
}

int LoginInfo::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:NetworkPacket.LoginInfo)
  int total_size = 0;

  // required .NetworkPacket.DeviceInfo device = 1;
  if (has_device()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->device_);
  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LoginInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const LoginInfo*>(&from));
}

void LoginInfo::MergeFrom(const LoginInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:NetworkPacket.LoginInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_device()) {
      mutable_device()->::NetworkPacket::DeviceInfo::MergeFrom(from.device());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void LoginInfo::CopyFrom(const LoginInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NetworkPacket.LoginInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoginInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_device()) {
    if (!this->device_->IsInitialized()) return false;
  }
  return true;
}

void LoginInfo::Swap(LoginInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void LoginInfo::InternalSwap(LoginInfo* other) {
  std::swap(device_, other->device_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string LoginInfo::GetTypeName() const {
  return "NetworkPacket.LoginInfo";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// LoginInfo

// required .NetworkPacket.DeviceInfo device = 1;
bool LoginInfo::has_device() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void LoginInfo::set_has_device() {
  _has_bits_[0] |= 0x00000001u;
}
void LoginInfo::clear_has_device() {
  _has_bits_[0] &= ~0x00000001u;
}
void LoginInfo::clear_device() {
  if (device_ != NULL) device_->::NetworkPacket::DeviceInfo::Clear();
  clear_has_device();
}
const ::NetworkPacket::DeviceInfo& LoginInfo::device() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.LoginInfo.device)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return device_ != NULL ? *device_ : *default_instance().device_;
#else
  return device_ != NULL ? *device_ : *default_instance_->device_;
#endif
}
::NetworkPacket::DeviceInfo* LoginInfo::mutable_device() {
  set_has_device();
  if (device_ == NULL) {
    device_ = new ::NetworkPacket::DeviceInfo;
  }
  // @@protoc_insertion_point(field_mutable:NetworkPacket.LoginInfo.device)
  return device_;
}
::NetworkPacket::DeviceInfo* LoginInfo::release_device() {
  // @@protoc_insertion_point(field_release:NetworkPacket.LoginInfo.device)
  clear_has_device();
  ::NetworkPacket::DeviceInfo* temp = device_;
  device_ = NULL;
  return temp;
}
void LoginInfo::set_allocated_device(::NetworkPacket::DeviceInfo* device) {
  delete device_;
  device_ = device;
  if (device) {
    set_has_device();
  } else {
    clear_has_device();
  }
  // @@protoc_insertion_point(field_set_allocated:NetworkPacket.LoginInfo.device)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForLogoutInfo(
    LogoutInfo* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int LogoutInfo::kDeviceFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

LogoutInfo::LogoutInfo()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:NetworkPacket.LogoutInfo)
}

void LogoutInfo::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  device_ = const_cast< ::NetworkPacket::DeviceInfo*>(
      ::NetworkPacket::DeviceInfo::internal_default_instance());
#else
  device_ = const_cast< ::NetworkPacket::DeviceInfo*>(&::NetworkPacket::DeviceInfo::default_instance());
#endif
}

LogoutInfo::LogoutInfo(const LogoutInfo& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:NetworkPacket.LogoutInfo)
}

void LogoutInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  device_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LogoutInfo::~LogoutInfo() {
  // @@protoc_insertion_point(destructor:NetworkPacket.LogoutInfo)
  SharedDtor();
}

void LogoutInfo::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete device_;
  }
}

void LogoutInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LogoutInfo& LogoutInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_NetworkPacket_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_NetworkPacket_2eproto();
#endif
  return *default_instance_;
}

LogoutInfo* LogoutInfo::default_instance_ = NULL;

LogoutInfo* LogoutInfo::New(::google::protobuf::Arena* arena) const {
  LogoutInfo* n = new LogoutInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void LogoutInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:NetworkPacket.LogoutInfo)
  if (has_device()) {
    if (device_ != NULL) device_->::NetworkPacket::DeviceInfo::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool LogoutInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForLogoutInfo, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:NetworkPacket.LogoutInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .NetworkPacket.DeviceInfo device = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_device()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:NetworkPacket.LogoutInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:NetworkPacket.LogoutInfo)
  return false;
#undef DO_
}

void LogoutInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:NetworkPacket.LogoutInfo)
  // required .NetworkPacket.DeviceInfo device = 1;
  if (has_device()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->device_, output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:NetworkPacket.LogoutInfo)
}

int LogoutInfo::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:NetworkPacket.LogoutInfo)
  int total_size = 0;

  // required .NetworkPacket.DeviceInfo device = 1;
  if (has_device()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->device_);
  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LogoutInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const LogoutInfo*>(&from));
}

void LogoutInfo::MergeFrom(const LogoutInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:NetworkPacket.LogoutInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_device()) {
      mutable_device()->::NetworkPacket::DeviceInfo::MergeFrom(from.device());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void LogoutInfo::CopyFrom(const LogoutInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NetworkPacket.LogoutInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LogoutInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_device()) {
    if (!this->device_->IsInitialized()) return false;
  }
  return true;
}

void LogoutInfo::Swap(LogoutInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void LogoutInfo::InternalSwap(LogoutInfo* other) {
  std::swap(device_, other->device_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string LogoutInfo::GetTypeName() const {
  return "NetworkPacket.LogoutInfo";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// LogoutInfo

// required .NetworkPacket.DeviceInfo device = 1;
bool LogoutInfo::has_device() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void LogoutInfo::set_has_device() {
  _has_bits_[0] |= 0x00000001u;
}
void LogoutInfo::clear_has_device() {
  _has_bits_[0] &= ~0x00000001u;
}
void LogoutInfo::clear_device() {
  if (device_ != NULL) device_->::NetworkPacket::DeviceInfo::Clear();
  clear_has_device();
}
const ::NetworkPacket::DeviceInfo& LogoutInfo::device() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.LogoutInfo.device)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return device_ != NULL ? *device_ : *default_instance().device_;
#else
  return device_ != NULL ? *device_ : *default_instance_->device_;
#endif
}
::NetworkPacket::DeviceInfo* LogoutInfo::mutable_device() {
  set_has_device();
  if (device_ == NULL) {
    device_ = new ::NetworkPacket::DeviceInfo;
  }
  // @@protoc_insertion_point(field_mutable:NetworkPacket.LogoutInfo.device)
  return device_;
}
::NetworkPacket::DeviceInfo* LogoutInfo::release_device() {
  // @@protoc_insertion_point(field_release:NetworkPacket.LogoutInfo.device)
  clear_has_device();
  ::NetworkPacket::DeviceInfo* temp = device_;
  device_ = NULL;
  return temp;
}
void LogoutInfo::set_allocated_device(::NetworkPacket::DeviceInfo* device) {
  delete device_;
  device_ = device;
  if (device) {
    set_has_device();
  } else {
    clear_has_device();
  }
  // @@protoc_insertion_point(field_set_allocated:NetworkPacket.LogoutInfo.device)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForThreadInfo(
    ThreadInfo* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ThreadInfo::kIdFieldNumber;
const int ThreadInfo::kNameFieldNumber;
const int ThreadInfo::kCpuUsageFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ThreadInfo::ThreadInfo()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:NetworkPacket.ThreadInfo)
}

void ThreadInfo::InitAsDefaultInstance() {
}

ThreadInfo::ThreadInfo(const ThreadInfo& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:NetworkPacket.ThreadInfo)
}

void ThreadInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  id_ = GOOGLE_ULONGLONG(0);
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  cpu_usage_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ThreadInfo::~ThreadInfo() {
  // @@protoc_insertion_point(destructor:NetworkPacket.ThreadInfo)
  SharedDtor();
}

void ThreadInfo::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ThreadInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ThreadInfo& ThreadInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_NetworkPacket_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_NetworkPacket_2eproto();
#endif
  return *default_instance_;
}

ThreadInfo* ThreadInfo::default_instance_ = NULL;

ThreadInfo* ThreadInfo::New(::google::protobuf::Arena* arena) const {
  ThreadInfo* n = new ThreadInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ThreadInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:NetworkPacket.ThreadInfo)
  if (_has_bits_[0 / 32] & 7u) {
    id_ = GOOGLE_ULONGLONG(0);
    if (has_name()) {
      name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    cpu_usage_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool ThreadInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForThreadInfo, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:NetworkPacket.ThreadInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_name;
        break;
      }

      // required string name = 2;
      case 2: {
        if (tag == 18) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(29)) goto parse_cpu_usage;
        break;
      }

      // required float cpu_usage = 3;
      case 3: {
        if (tag == 29) {
         parse_cpu_usage:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &cpu_usage_)));
          set_has_cpu_usage();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:NetworkPacket.ThreadInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:NetworkPacket.ThreadInfo)
  return false;
#undef DO_
}

void ThreadInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:NetworkPacket.ThreadInfo)
  // required uint64 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->id(), output);
  }

  // required string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->name(), output);
  }

  // required float cpu_usage = 3;
  if (has_cpu_usage()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->cpu_usage(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:NetworkPacket.ThreadInfo)
}

int ThreadInfo::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:NetworkPacket.ThreadInfo)
  int total_size = 0;

  if (has_id()) {
    // required uint64 id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->id());
  }

  if (has_name()) {
    // required string name = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->name());
  }

  if (has_cpu_usage()) {
    // required float cpu_usage = 3;
    total_size += 1 + 4;
  }

  return total_size;
}
int ThreadInfo::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:NetworkPacket.ThreadInfo)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required uint64 id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->id());

    // required string name = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->name());

    // required float cpu_usage = 3;
    total_size += 1 + 4;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ThreadInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ThreadInfo*>(&from));
}

void ThreadInfo::MergeFrom(const ThreadInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:NetworkPacket.ThreadInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_name()) {
      set_has_name();
      name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (from.has_cpu_usage()) {
      set_cpu_usage(from.cpu_usage());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void ThreadInfo::CopyFrom(const ThreadInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NetworkPacket.ThreadInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ThreadInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void ThreadInfo::Swap(ThreadInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ThreadInfo::InternalSwap(ThreadInfo* other) {
  std::swap(id_, other->id_);
  name_.Swap(&other->name_);
  std::swap(cpu_usage_, other->cpu_usage_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string ThreadInfo::GetTypeName() const {
  return "NetworkPacket.ThreadInfo";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ThreadInfo

// required uint64 id = 1;
bool ThreadInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ThreadInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
void ThreadInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
void ThreadInfo::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
 ::google::protobuf::uint64 ThreadInfo::id() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.ThreadInfo.id)
  return id_;
}
 void ThreadInfo::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.ThreadInfo.id)
}

// required string name = 2;
bool ThreadInfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ThreadInfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
void ThreadInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
void ThreadInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
 const ::std::string& ThreadInfo::name() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.ThreadInfo.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ThreadInfo::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NetworkPacket.ThreadInfo.name)
}
 void ThreadInfo::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NetworkPacket.ThreadInfo.name)
}
 void ThreadInfo::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NetworkPacket.ThreadInfo.name)
}
 ::std::string* ThreadInfo::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:NetworkPacket.ThreadInfo.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* ThreadInfo::release_name() {
  // @@protoc_insertion_point(field_release:NetworkPacket.ThreadInfo.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ThreadInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:NetworkPacket.ThreadInfo.name)
}

// required float cpu_usage = 3;
bool ThreadInfo::has_cpu_usage() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void ThreadInfo::set_has_cpu_usage() {
  _has_bits_[0] |= 0x00000004u;
}
void ThreadInfo::clear_has_cpu_usage() {
  _has_bits_[0] &= ~0x00000004u;
}
void ThreadInfo::clear_cpu_usage() {
  cpu_usage_ = 0;
  clear_has_cpu_usage();
}
 float ThreadInfo::cpu_usage() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.ThreadInfo.cpu_usage)
  return cpu_usage_;
}
 void ThreadInfo::set_cpu_usage(float value) {
  set_has_cpu_usage();
  cpu_usage_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.ThreadInfo.cpu_usage)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForThreadsInfo(
    ThreadsInfo* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ThreadsInfo::kUidFieldNumber;
const int ThreadsInfo::kThreadsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ThreadsInfo::ThreadsInfo()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:NetworkPacket.ThreadsInfo)
}

void ThreadsInfo::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  uid_ = const_cast< ::NetworkPacket::UID*>(
      ::NetworkPacket::UID::internal_default_instance());
#else
  uid_ = const_cast< ::NetworkPacket::UID*>(&::NetworkPacket::UID::default_instance());
#endif
}

ThreadsInfo::ThreadsInfo(const ThreadsInfo& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:NetworkPacket.ThreadsInfo)
}

void ThreadsInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  uid_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ThreadsInfo::~ThreadsInfo() {
  // @@protoc_insertion_point(destructor:NetworkPacket.ThreadsInfo)
  SharedDtor();
}

void ThreadsInfo::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete uid_;
  }
}

void ThreadsInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ThreadsInfo& ThreadsInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_NetworkPacket_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_NetworkPacket_2eproto();
#endif
  return *default_instance_;
}

ThreadsInfo* ThreadsInfo::default_instance_ = NULL;

ThreadsInfo* ThreadsInfo::New(::google::protobuf::Arena* arena) const {
  ThreadsInfo* n = new ThreadsInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ThreadsInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:NetworkPacket.ThreadsInfo)
  if (has_uid()) {
    if (uid_ != NULL) uid_->::NetworkPacket::UID::Clear();
  }
  threads_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool ThreadsInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForThreadsInfo, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:NetworkPacket.ThreadsInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .NetworkPacket.UID uid = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_uid()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_threads;
        break;
      }

      // repeated .NetworkPacket.ThreadInfo threads = 2;
      case 2: {
        if (tag == 18) {
         parse_threads:
          DO_(input->IncrementRecursionDepth());
         parse_loop_threads:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_threads()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_loop_threads;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:NetworkPacket.ThreadsInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:NetworkPacket.ThreadsInfo)
  return false;
#undef DO_
}

void ThreadsInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:NetworkPacket.ThreadsInfo)
  // required .NetworkPacket.UID uid = 1;
  if (has_uid()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->uid_, output);
  }

  // repeated .NetworkPacket.ThreadInfo threads = 2;
  for (unsigned int i = 0, n = this->threads_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->threads(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:NetworkPacket.ThreadsInfo)
}

int ThreadsInfo::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:NetworkPacket.ThreadsInfo)
  int total_size = 0;

  // required .NetworkPacket.UID uid = 1;
  if (has_uid()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->uid_);
  }
  // repeated .NetworkPacket.ThreadInfo threads = 2;
  total_size += 1 * this->threads_size();
  for (int i = 0; i < this->threads_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->threads(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ThreadsInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ThreadsInfo*>(&from));
}

void ThreadsInfo::MergeFrom(const ThreadsInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:NetworkPacket.ThreadsInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  threads_.MergeFrom(from.threads_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uid()) {
      mutable_uid()->::NetworkPacket::UID::MergeFrom(from.uid());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void ThreadsInfo::CopyFrom(const ThreadsInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NetworkPacket.ThreadsInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ThreadsInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_uid()) {
    if (!this->uid_->IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->threads())) return false;
  return true;
}

void ThreadsInfo::Swap(ThreadsInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ThreadsInfo::InternalSwap(ThreadsInfo* other) {
  std::swap(uid_, other->uid_);
  threads_.UnsafeArenaSwap(&other->threads_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string ThreadsInfo::GetTypeName() const {
  return "NetworkPacket.ThreadsInfo";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ThreadsInfo

// required .NetworkPacket.UID uid = 1;
bool ThreadsInfo::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ThreadsInfo::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
void ThreadsInfo::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
void ThreadsInfo::clear_uid() {
  if (uid_ != NULL) uid_->::NetworkPacket::UID::Clear();
  clear_has_uid();
}
const ::NetworkPacket::UID& ThreadsInfo::uid() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.ThreadsInfo.uid)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return uid_ != NULL ? *uid_ : *default_instance().uid_;
#else
  return uid_ != NULL ? *uid_ : *default_instance_->uid_;
#endif
}
::NetworkPacket::UID* ThreadsInfo::mutable_uid() {
  set_has_uid();
  if (uid_ == NULL) {
    uid_ = new ::NetworkPacket::UID;
  }
  // @@protoc_insertion_point(field_mutable:NetworkPacket.ThreadsInfo.uid)
  return uid_;
}
::NetworkPacket::UID* ThreadsInfo::release_uid() {
  // @@protoc_insertion_point(field_release:NetworkPacket.ThreadsInfo.uid)
  clear_has_uid();
  ::NetworkPacket::UID* temp = uid_;
  uid_ = NULL;
  return temp;
}
void ThreadsInfo::set_allocated_uid(::NetworkPacket::UID* uid) {
  delete uid_;
  uid_ = uid;
  if (uid) {
    set_has_uid();
  } else {
    clear_has_uid();
  }
  // @@protoc_insertion_point(field_set_allocated:NetworkPacket.ThreadsInfo.uid)
}

// repeated .NetworkPacket.ThreadInfo threads = 2;
int ThreadsInfo::threads_size() const {
  return threads_.size();
}
void ThreadsInfo::clear_threads() {
  threads_.Clear();
}
const ::NetworkPacket::ThreadInfo& ThreadsInfo::threads(int index) const {
  // @@protoc_insertion_point(field_get:NetworkPacket.ThreadsInfo.threads)
  return threads_.Get(index);
}
::NetworkPacket::ThreadInfo* ThreadsInfo::mutable_threads(int index) {
  // @@protoc_insertion_point(field_mutable:NetworkPacket.ThreadsInfo.threads)
  return threads_.Mutable(index);
}
::NetworkPacket::ThreadInfo* ThreadsInfo::add_threads() {
  // @@protoc_insertion_point(field_add:NetworkPacket.ThreadsInfo.threads)
  return threads_.Add();
}
::google::protobuf::RepeatedPtrField< ::NetworkPacket::ThreadInfo >*
ThreadsInfo::mutable_threads() {
  // @@protoc_insertion_point(field_mutable_list:NetworkPacket.ThreadsInfo.threads)
  return &threads_;
}
const ::google::protobuf::RepeatedPtrField< ::NetworkPacket::ThreadInfo >&
ThreadsInfo::threads() const {
  // @@protoc_insertion_point(field_list:NetworkPacket.ThreadsInfo.threads)
  return threads_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForLogStringInfo(
    LogStringInfo* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int LogStringInfo::kUidFieldNumber;
const int LogStringInfo::kHasCompressedFieldNumber;
const int LogStringInfo::kLogFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

LogStringInfo::LogStringInfo()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:NetworkPacket.LogStringInfo)
}

void LogStringInfo::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  uid_ = const_cast< ::NetworkPacket::UID*>(
      ::NetworkPacket::UID::internal_default_instance());
#else
  uid_ = const_cast< ::NetworkPacket::UID*>(&::NetworkPacket::UID::default_instance());
#endif
}

LogStringInfo::LogStringInfo(const LogStringInfo& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:NetworkPacket.LogStringInfo)
}

void LogStringInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  uid_ = NULL;
  has_compressed_ = false;
  log_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LogStringInfo::~LogStringInfo() {
  // @@protoc_insertion_point(destructor:NetworkPacket.LogStringInfo)
  SharedDtor();
}

void LogStringInfo::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  log_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete uid_;
  }
}

void LogStringInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LogStringInfo& LogStringInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_NetworkPacket_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_NetworkPacket_2eproto();
#endif
  return *default_instance_;
}

LogStringInfo* LogStringInfo::default_instance_ = NULL;

LogStringInfo* LogStringInfo::New(::google::protobuf::Arena* arena) const {
  LogStringInfo* n = new LogStringInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void LogStringInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:NetworkPacket.LogStringInfo)
  if (_has_bits_[0 / 32] & 7u) {
    if (has_uid()) {
      if (uid_ != NULL) uid_->::NetworkPacket::UID::Clear();
    }
    has_compressed_ = false;
    if (has_log()) {
      log_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool LogStringInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForLogStringInfo, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:NetworkPacket.LogStringInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .NetworkPacket.UID uid = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_uid()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_has_compressed;
        break;
      }

      // required bool has_compressed = 2;
      case 2: {
        if (tag == 16) {
         parse_has_compressed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_compressed_)));
          set_has_has_compressed();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_log;
        break;
      }

      // required bytes log = 3;
      case 3: {
        if (tag == 26) {
         parse_log:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_log()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:NetworkPacket.LogStringInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:NetworkPacket.LogStringInfo)
  return false;
#undef DO_
}

void LogStringInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:NetworkPacket.LogStringInfo)
  // required .NetworkPacket.UID uid = 1;
  if (has_uid()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->uid_, output);
  }

  // required bool has_compressed = 2;
  if (has_has_compressed()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->has_compressed(), output);
  }

  // required bytes log = 3;
  if (has_log()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->log(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:NetworkPacket.LogStringInfo)
}

int LogStringInfo::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:NetworkPacket.LogStringInfo)
  int total_size = 0;

  if (has_uid()) {
    // required .NetworkPacket.UID uid = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->uid_);
  }

  if (has_has_compressed()) {
    // required bool has_compressed = 2;
    total_size += 1 + 1;
  }

  if (has_log()) {
    // required bytes log = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->log());
  }

  return total_size;
}
int LogStringInfo::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:NetworkPacket.LogStringInfo)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required .NetworkPacket.UID uid = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->uid_);

    // required bool has_compressed = 2;
    total_size += 1 + 1;

    // required bytes log = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->log());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LogStringInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const LogStringInfo*>(&from));
}

void LogStringInfo::MergeFrom(const LogStringInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:NetworkPacket.LogStringInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uid()) {
      mutable_uid()->::NetworkPacket::UID::MergeFrom(from.uid());
    }
    if (from.has_has_compressed()) {
      set_has_compressed(from.has_compressed());
    }
    if (from.has_log()) {
      set_has_log();
      log_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.log_);
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void LogStringInfo::CopyFrom(const LogStringInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NetworkPacket.LogStringInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LogStringInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  if (has_uid()) {
    if (!this->uid_->IsInitialized()) return false;
  }
  return true;
}

void LogStringInfo::Swap(LogStringInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void LogStringInfo::InternalSwap(LogStringInfo* other) {
  std::swap(uid_, other->uid_);
  std::swap(has_compressed_, other->has_compressed_);
  log_.Swap(&other->log_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string LogStringInfo::GetTypeName() const {
  return "NetworkPacket.LogStringInfo";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// LogStringInfo

// required .NetworkPacket.UID uid = 1;
bool LogStringInfo::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void LogStringInfo::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
void LogStringInfo::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
void LogStringInfo::clear_uid() {
  if (uid_ != NULL) uid_->::NetworkPacket::UID::Clear();
  clear_has_uid();
}
const ::NetworkPacket::UID& LogStringInfo::uid() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.LogStringInfo.uid)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return uid_ != NULL ? *uid_ : *default_instance().uid_;
#else
  return uid_ != NULL ? *uid_ : *default_instance_->uid_;
#endif
}
::NetworkPacket::UID* LogStringInfo::mutable_uid() {
  set_has_uid();
  if (uid_ == NULL) {
    uid_ = new ::NetworkPacket::UID;
  }
  // @@protoc_insertion_point(field_mutable:NetworkPacket.LogStringInfo.uid)
  return uid_;
}
::NetworkPacket::UID* LogStringInfo::release_uid() {
  // @@protoc_insertion_point(field_release:NetworkPacket.LogStringInfo.uid)
  clear_has_uid();
  ::NetworkPacket::UID* temp = uid_;
  uid_ = NULL;
  return temp;
}
void LogStringInfo::set_allocated_uid(::NetworkPacket::UID* uid) {
  delete uid_;
  uid_ = uid;
  if (uid) {
    set_has_uid();
  } else {
    clear_has_uid();
  }
  // @@protoc_insertion_point(field_set_allocated:NetworkPacket.LogStringInfo.uid)
}

// required bool has_compressed = 2;
bool LogStringInfo::has_has_compressed() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void LogStringInfo::set_has_has_compressed() {
  _has_bits_[0] |= 0x00000002u;
}
void LogStringInfo::clear_has_has_compressed() {
  _has_bits_[0] &= ~0x00000002u;
}
void LogStringInfo::clear_has_compressed() {
  has_compressed_ = false;
  clear_has_has_compressed();
}
 bool LogStringInfo::has_compressed() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.LogStringInfo.has_compressed)
  return has_compressed_;
}
 void LogStringInfo::set_has_compressed(bool value) {
  set_has_has_compressed();
  has_compressed_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.LogStringInfo.has_compressed)
}

// required bytes log = 3;
bool LogStringInfo::has_log() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void LogStringInfo::set_has_log() {
  _has_bits_[0] |= 0x00000004u;
}
void LogStringInfo::clear_has_log() {
  _has_bits_[0] &= ~0x00000004u;
}
void LogStringInfo::clear_log() {
  log_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_log();
}
 const ::std::string& LogStringInfo::log() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.LogStringInfo.log)
  return log_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void LogStringInfo::set_log(const ::std::string& value) {
  set_has_log();
  log_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NetworkPacket.LogStringInfo.log)
}
 void LogStringInfo::set_log(const char* value) {
  set_has_log();
  log_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NetworkPacket.LogStringInfo.log)
}
 void LogStringInfo::set_log(const void* value, size_t size) {
  set_has_log();
  log_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NetworkPacket.LogStringInfo.log)
}
 ::std::string* LogStringInfo::mutable_log() {
  set_has_log();
  // @@protoc_insertion_point(field_mutable:NetworkPacket.LogStringInfo.log)
  return log_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* LogStringInfo::release_log() {
  // @@protoc_insertion_point(field_release:NetworkPacket.LogStringInfo.log)
  clear_has_log();
  return log_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void LogStringInfo::set_allocated_log(::std::string* log) {
  if (log != NULL) {
    set_has_log();
  } else {
    clear_has_log();
  }
  log_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), log);
  // @@protoc_insertion_point(field_set_allocated:NetworkPacket.LogStringInfo.log)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForTextureResInfo(
    TextureResInfo* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TextureResInfo::kResNameFieldNumber;
const int TextureResInfo::kTypeFieldNumber;
const int TextureResInfo::kResIdFieldNumber;
const int TextureResInfo::kWidthFieldNumber;
const int TextureResInfo::kHeightFieldNumber;
const int TextureResInfo::kMipmapsFieldNumber;
const int TextureResInfo::kSizeInBytesFieldNumber;
const int TextureResInfo::kPixelFormatFieldNumber;
const int TextureResInfo::kSamplerFilterTypeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TextureResInfo::TextureResInfo()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:NetworkPacket.TextureResInfo)
}

void TextureResInfo::InitAsDefaultInstance() {
}

TextureResInfo::TextureResInfo(const TextureResInfo& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:NetworkPacket.TextureResInfo)
}

void TextureResInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  res_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  type_ = 1;
  res_id_ = 0u;
  width_ = 0u;
  height_ = 0u;
  mipmaps_ = 0u;
  size_in_bytes_ = 0u;
  pixel_format_ = 0u;
  sampler_filter_type_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TextureResInfo::~TextureResInfo() {
  // @@protoc_insertion_point(destructor:NetworkPacket.TextureResInfo)
  SharedDtor();
}

void TextureResInfo::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  res_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void TextureResInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TextureResInfo& TextureResInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_NetworkPacket_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_NetworkPacket_2eproto();
#endif
  return *default_instance_;
}

TextureResInfo* TextureResInfo::default_instance_ = NULL;

TextureResInfo* TextureResInfo::New(::google::protobuf::Arena* arena) const {
  TextureResInfo* n = new TextureResInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TextureResInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:NetworkPacket.TextureResInfo)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(TextureResInfo, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<TextureResInfo*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 255u) {
    ZR_(res_id_, pixel_format_);
    if (has_res_name()) {
      res_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    type_ = 1;
  }
  sampler_filter_type_ = 1;

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool TextureResInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForTextureResInfo, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:NetworkPacket.TextureResInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string res_name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_res_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_type;
        break;
      }

      // required .NetworkPacket.TextureType type = 2;
      case 2: {
        if (tag == 16) {
         parse_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::NetworkPacket::TextureType_IsValid(value)) {
            set_type(static_cast< ::NetworkPacket::TextureType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(16);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_res_id;
        break;
      }

      // required uint32 res_id = 3;
      case 3: {
        if (tag == 24) {
         parse_res_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &res_id_)));
          set_has_res_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_width;
        break;
      }

      // required uint32 width = 4;
      case 4: {
        if (tag == 32) {
         parse_width:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &width_)));
          set_has_width();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_height;
        break;
      }

      // required uint32 height = 5;
      case 5: {
        if (tag == 40) {
         parse_height:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &height_)));
          set_has_height();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_mipmaps;
        break;
      }

      // required uint32 mipmaps = 6;
      case 6: {
        if (tag == 48) {
         parse_mipmaps:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &mipmaps_)));
          set_has_mipmaps();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_size_in_bytes;
        break;
      }

      // required uint32 size_in_bytes = 7;
      case 7: {
        if (tag == 56) {
         parse_size_in_bytes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &size_in_bytes_)));
          set_has_size_in_bytes();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_pixel_format;
        break;
      }

      // required uint32 pixel_format = 8;
      case 8: {
        if (tag == 64) {
         parse_pixel_format:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &pixel_format_)));
          set_has_pixel_format();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_sampler_filter_type;
        break;
      }

      // required .NetworkPacket.SamplerType sampler_filter_type = 9;
      case 9: {
        if (tag == 72) {
         parse_sampler_filter_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::NetworkPacket::SamplerType_IsValid(value)) {
            set_sampler_filter_type(static_cast< ::NetworkPacket::SamplerType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(72);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:NetworkPacket.TextureResInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:NetworkPacket.TextureResInfo)
  return false;
#undef DO_
}

void TextureResInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:NetworkPacket.TextureResInfo)
  // required string res_name = 1;
  if (has_res_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->res_name(), output);
  }

  // required .NetworkPacket.TextureType type = 2;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->type(), output);
  }

  // required uint32 res_id = 3;
  if (has_res_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->res_id(), output);
  }

  // required uint32 width = 4;
  if (has_width()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->width(), output);
  }

  // required uint32 height = 5;
  if (has_height()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->height(), output);
  }

  // required uint32 mipmaps = 6;
  if (has_mipmaps()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->mipmaps(), output);
  }

  // required uint32 size_in_bytes = 7;
  if (has_size_in_bytes()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->size_in_bytes(), output);
  }

  // required uint32 pixel_format = 8;
  if (has_pixel_format()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->pixel_format(), output);
  }

  // required .NetworkPacket.SamplerType sampler_filter_type = 9;
  if (has_sampler_filter_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      9, this->sampler_filter_type(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:NetworkPacket.TextureResInfo)
}

int TextureResInfo::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:NetworkPacket.TextureResInfo)
  int total_size = 0;

  if (has_res_name()) {
    // required string res_name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->res_name());
  }

  if (has_type()) {
    // required .NetworkPacket.TextureType type = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
  }

  if (has_res_id()) {
    // required uint32 res_id = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->res_id());
  }

  if (has_width()) {
    // required uint32 width = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->width());
  }

  if (has_height()) {
    // required uint32 height = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->height());
  }

  if (has_mipmaps()) {
    // required uint32 mipmaps = 6;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->mipmaps());
  }

  if (has_size_in_bytes()) {
    // required uint32 size_in_bytes = 7;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->size_in_bytes());
  }

  if (has_pixel_format()) {
    // required uint32 pixel_format = 8;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->pixel_format());
  }

  if (has_sampler_filter_type()) {
    // required .NetworkPacket.SamplerType sampler_filter_type = 9;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->sampler_filter_type());
  }

  return total_size;
}
int TextureResInfo::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:NetworkPacket.TextureResInfo)
  int total_size = 0;

  if (((_has_bits_[0] & 0x000001ff) ^ 0x000001ff) == 0) {  // All required fields are present.
    // required string res_name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->res_name());

    // required .NetworkPacket.TextureType type = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());

    // required uint32 res_id = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->res_id());

    // required uint32 width = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->width());

    // required uint32 height = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->height());

    // required uint32 mipmaps = 6;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->mipmaps());

    // required uint32 size_in_bytes = 7;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->size_in_bytes());

    // required uint32 pixel_format = 8;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->pixel_format());

    // required .NetworkPacket.SamplerType sampler_filter_type = 9;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->sampler_filter_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TextureResInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TextureResInfo*>(&from));
}

void TextureResInfo::MergeFrom(const TextureResInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:NetworkPacket.TextureResInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_res_name()) {
      set_has_res_name();
      res_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.res_name_);
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_res_id()) {
      set_res_id(from.res_id());
    }
    if (from.has_width()) {
      set_width(from.width());
    }
    if (from.has_height()) {
      set_height(from.height());
    }
    if (from.has_mipmaps()) {
      set_mipmaps(from.mipmaps());
    }
    if (from.has_size_in_bytes()) {
      set_size_in_bytes(from.size_in_bytes());
    }
    if (from.has_pixel_format()) {
      set_pixel_format(from.pixel_format());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_sampler_filter_type()) {
      set_sampler_filter_type(from.sampler_filter_type());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void TextureResInfo::CopyFrom(const TextureResInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NetworkPacket.TextureResInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TextureResInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x000001ff) != 0x000001ff) return false;

  return true;
}

void TextureResInfo::Swap(TextureResInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TextureResInfo::InternalSwap(TextureResInfo* other) {
  res_name_.Swap(&other->res_name_);
  std::swap(type_, other->type_);
  std::swap(res_id_, other->res_id_);
  std::swap(width_, other->width_);
  std::swap(height_, other->height_);
  std::swap(mipmaps_, other->mipmaps_);
  std::swap(size_in_bytes_, other->size_in_bytes_);
  std::swap(pixel_format_, other->pixel_format_);
  std::swap(sampler_filter_type_, other->sampler_filter_type_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string TextureResInfo::GetTypeName() const {
  return "NetworkPacket.TextureResInfo";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// TextureResInfo

// required string res_name = 1;
bool TextureResInfo::has_res_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void TextureResInfo::set_has_res_name() {
  _has_bits_[0] |= 0x00000001u;
}
void TextureResInfo::clear_has_res_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void TextureResInfo::clear_res_name() {
  res_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_res_name();
}
 const ::std::string& TextureResInfo::res_name() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.TextureResInfo.res_name)
  return res_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void TextureResInfo::set_res_name(const ::std::string& value) {
  set_has_res_name();
  res_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NetworkPacket.TextureResInfo.res_name)
}
 void TextureResInfo::set_res_name(const char* value) {
  set_has_res_name();
  res_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NetworkPacket.TextureResInfo.res_name)
}
 void TextureResInfo::set_res_name(const char* value, size_t size) {
  set_has_res_name();
  res_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NetworkPacket.TextureResInfo.res_name)
}
 ::std::string* TextureResInfo::mutable_res_name() {
  set_has_res_name();
  // @@protoc_insertion_point(field_mutable:NetworkPacket.TextureResInfo.res_name)
  return res_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* TextureResInfo::release_res_name() {
  // @@protoc_insertion_point(field_release:NetworkPacket.TextureResInfo.res_name)
  clear_has_res_name();
  return res_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void TextureResInfo::set_allocated_res_name(::std::string* res_name) {
  if (res_name != NULL) {
    set_has_res_name();
  } else {
    clear_has_res_name();
  }
  res_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), res_name);
  // @@protoc_insertion_point(field_set_allocated:NetworkPacket.TextureResInfo.res_name)
}

// required .NetworkPacket.TextureType type = 2;
bool TextureResInfo::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void TextureResInfo::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
void TextureResInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
void TextureResInfo::clear_type() {
  type_ = 1;
  clear_has_type();
}
 ::NetworkPacket::TextureType TextureResInfo::type() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.TextureResInfo.type)
  return static_cast< ::NetworkPacket::TextureType >(type_);
}
 void TextureResInfo::set_type(::NetworkPacket::TextureType value) {
  assert(::NetworkPacket::TextureType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.TextureResInfo.type)
}

// required uint32 res_id = 3;
bool TextureResInfo::has_res_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void TextureResInfo::set_has_res_id() {
  _has_bits_[0] |= 0x00000004u;
}
void TextureResInfo::clear_has_res_id() {
  _has_bits_[0] &= ~0x00000004u;
}
void TextureResInfo::clear_res_id() {
  res_id_ = 0u;
  clear_has_res_id();
}
 ::google::protobuf::uint32 TextureResInfo::res_id() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.TextureResInfo.res_id)
  return res_id_;
}
 void TextureResInfo::set_res_id(::google::protobuf::uint32 value) {
  set_has_res_id();
  res_id_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.TextureResInfo.res_id)
}

// required uint32 width = 4;
bool TextureResInfo::has_width() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void TextureResInfo::set_has_width() {
  _has_bits_[0] |= 0x00000008u;
}
void TextureResInfo::clear_has_width() {
  _has_bits_[0] &= ~0x00000008u;
}
void TextureResInfo::clear_width() {
  width_ = 0u;
  clear_has_width();
}
 ::google::protobuf::uint32 TextureResInfo::width() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.TextureResInfo.width)
  return width_;
}
 void TextureResInfo::set_width(::google::protobuf::uint32 value) {
  set_has_width();
  width_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.TextureResInfo.width)
}

// required uint32 height = 5;
bool TextureResInfo::has_height() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void TextureResInfo::set_has_height() {
  _has_bits_[0] |= 0x00000010u;
}
void TextureResInfo::clear_has_height() {
  _has_bits_[0] &= ~0x00000010u;
}
void TextureResInfo::clear_height() {
  height_ = 0u;
  clear_has_height();
}
 ::google::protobuf::uint32 TextureResInfo::height() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.TextureResInfo.height)
  return height_;
}
 void TextureResInfo::set_height(::google::protobuf::uint32 value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.TextureResInfo.height)
}

// required uint32 mipmaps = 6;
bool TextureResInfo::has_mipmaps() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void TextureResInfo::set_has_mipmaps() {
  _has_bits_[0] |= 0x00000020u;
}
void TextureResInfo::clear_has_mipmaps() {
  _has_bits_[0] &= ~0x00000020u;
}
void TextureResInfo::clear_mipmaps() {
  mipmaps_ = 0u;
  clear_has_mipmaps();
}
 ::google::protobuf::uint32 TextureResInfo::mipmaps() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.TextureResInfo.mipmaps)
  return mipmaps_;
}
 void TextureResInfo::set_mipmaps(::google::protobuf::uint32 value) {
  set_has_mipmaps();
  mipmaps_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.TextureResInfo.mipmaps)
}

// required uint32 size_in_bytes = 7;
bool TextureResInfo::has_size_in_bytes() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void TextureResInfo::set_has_size_in_bytes() {
  _has_bits_[0] |= 0x00000040u;
}
void TextureResInfo::clear_has_size_in_bytes() {
  _has_bits_[0] &= ~0x00000040u;
}
void TextureResInfo::clear_size_in_bytes() {
  size_in_bytes_ = 0u;
  clear_has_size_in_bytes();
}
 ::google::protobuf::uint32 TextureResInfo::size_in_bytes() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.TextureResInfo.size_in_bytes)
  return size_in_bytes_;
}
 void TextureResInfo::set_size_in_bytes(::google::protobuf::uint32 value) {
  set_has_size_in_bytes();
  size_in_bytes_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.TextureResInfo.size_in_bytes)
}

// required uint32 pixel_format = 8;
bool TextureResInfo::has_pixel_format() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void TextureResInfo::set_has_pixel_format() {
  _has_bits_[0] |= 0x00000080u;
}
void TextureResInfo::clear_has_pixel_format() {
  _has_bits_[0] &= ~0x00000080u;
}
void TextureResInfo::clear_pixel_format() {
  pixel_format_ = 0u;
  clear_has_pixel_format();
}
 ::google::protobuf::uint32 TextureResInfo::pixel_format() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.TextureResInfo.pixel_format)
  return pixel_format_;
}
 void TextureResInfo::set_pixel_format(::google::protobuf::uint32 value) {
  set_has_pixel_format();
  pixel_format_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.TextureResInfo.pixel_format)
}

// required .NetworkPacket.SamplerType sampler_filter_type = 9;
bool TextureResInfo::has_sampler_filter_type() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void TextureResInfo::set_has_sampler_filter_type() {
  _has_bits_[0] |= 0x00000100u;
}
void TextureResInfo::clear_has_sampler_filter_type() {
  _has_bits_[0] &= ~0x00000100u;
}
void TextureResInfo::clear_sampler_filter_type() {
  sampler_filter_type_ = 1;
  clear_has_sampler_filter_type();
}
 ::NetworkPacket::SamplerType TextureResInfo::sampler_filter_type() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.TextureResInfo.sampler_filter_type)
  return static_cast< ::NetworkPacket::SamplerType >(sampler_filter_type_);
}
 void TextureResInfo::set_sampler_filter_type(::NetworkPacket::SamplerType value) {
  assert(::NetworkPacket::SamplerType_IsValid(value));
  set_has_sampler_filter_type();
  sampler_filter_type_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.TextureResInfo.sampler_filter_type)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForTextureChangeSamplerFilter(
    TextureChangeSamplerFilter* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TextureChangeSamplerFilter::kResIdFieldNumber;
const int TextureChangeSamplerFilter::kSamplerFilterTypeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TextureChangeSamplerFilter::TextureChangeSamplerFilter()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:NetworkPacket.TextureChangeSamplerFilter)
}

void TextureChangeSamplerFilter::InitAsDefaultInstance() {
}

TextureChangeSamplerFilter::TextureChangeSamplerFilter(const TextureChangeSamplerFilter& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:NetworkPacket.TextureChangeSamplerFilter)
}

void TextureChangeSamplerFilter::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  res_id_ = 0u;
  sampler_filter_type_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TextureChangeSamplerFilter::~TextureChangeSamplerFilter() {
  // @@protoc_insertion_point(destructor:NetworkPacket.TextureChangeSamplerFilter)
  SharedDtor();
}

void TextureChangeSamplerFilter::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void TextureChangeSamplerFilter::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TextureChangeSamplerFilter& TextureChangeSamplerFilter::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_NetworkPacket_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_NetworkPacket_2eproto();
#endif
  return *default_instance_;
}

TextureChangeSamplerFilter* TextureChangeSamplerFilter::default_instance_ = NULL;

TextureChangeSamplerFilter* TextureChangeSamplerFilter::New(::google::protobuf::Arena* arena) const {
  TextureChangeSamplerFilter* n = new TextureChangeSamplerFilter;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TextureChangeSamplerFilter::Clear() {
// @@protoc_insertion_point(message_clear_start:NetworkPacket.TextureChangeSamplerFilter)
  if (_has_bits_[0 / 32] & 3u) {
    res_id_ = 0u;
    sampler_filter_type_ = 1;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool TextureChangeSamplerFilter::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForTextureChangeSamplerFilter, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:NetworkPacket.TextureChangeSamplerFilter)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 res_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &res_id_)));
          set_has_res_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_sampler_filter_type;
        break;
      }

      // required .NetworkPacket.SamplerType sampler_filter_type = 2;
      case 2: {
        if (tag == 16) {
         parse_sampler_filter_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::NetworkPacket::SamplerType_IsValid(value)) {
            set_sampler_filter_type(static_cast< ::NetworkPacket::SamplerType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(16);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:NetworkPacket.TextureChangeSamplerFilter)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:NetworkPacket.TextureChangeSamplerFilter)
  return false;
#undef DO_
}

void TextureChangeSamplerFilter::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:NetworkPacket.TextureChangeSamplerFilter)
  // required uint32 res_id = 1;
  if (has_res_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->res_id(), output);
  }

  // required .NetworkPacket.SamplerType sampler_filter_type = 2;
  if (has_sampler_filter_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->sampler_filter_type(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:NetworkPacket.TextureChangeSamplerFilter)
}

int TextureChangeSamplerFilter::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:NetworkPacket.TextureChangeSamplerFilter)
  int total_size = 0;

  if (has_res_id()) {
    // required uint32 res_id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->res_id());
  }

  if (has_sampler_filter_type()) {
    // required .NetworkPacket.SamplerType sampler_filter_type = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->sampler_filter_type());
  }

  return total_size;
}
int TextureChangeSamplerFilter::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:NetworkPacket.TextureChangeSamplerFilter)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint32 res_id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->res_id());

    // required .NetworkPacket.SamplerType sampler_filter_type = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->sampler_filter_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TextureChangeSamplerFilter::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TextureChangeSamplerFilter*>(&from));
}

void TextureChangeSamplerFilter::MergeFrom(const TextureChangeSamplerFilter& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:NetworkPacket.TextureChangeSamplerFilter)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_res_id()) {
      set_res_id(from.res_id());
    }
    if (from.has_sampler_filter_type()) {
      set_sampler_filter_type(from.sampler_filter_type());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void TextureChangeSamplerFilter::CopyFrom(const TextureChangeSamplerFilter& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NetworkPacket.TextureChangeSamplerFilter)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TextureChangeSamplerFilter::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void TextureChangeSamplerFilter::Swap(TextureChangeSamplerFilter* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TextureChangeSamplerFilter::InternalSwap(TextureChangeSamplerFilter* other) {
  std::swap(res_id_, other->res_id_);
  std::swap(sampler_filter_type_, other->sampler_filter_type_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string TextureChangeSamplerFilter::GetTypeName() const {
  return "NetworkPacket.TextureChangeSamplerFilter";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// TextureChangeSamplerFilter

// required uint32 res_id = 1;
bool TextureChangeSamplerFilter::has_res_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void TextureChangeSamplerFilter::set_has_res_id() {
  _has_bits_[0] |= 0x00000001u;
}
void TextureChangeSamplerFilter::clear_has_res_id() {
  _has_bits_[0] &= ~0x00000001u;
}
void TextureChangeSamplerFilter::clear_res_id() {
  res_id_ = 0u;
  clear_has_res_id();
}
 ::google::protobuf::uint32 TextureChangeSamplerFilter::res_id() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.TextureChangeSamplerFilter.res_id)
  return res_id_;
}
 void TextureChangeSamplerFilter::set_res_id(::google::protobuf::uint32 value) {
  set_has_res_id();
  res_id_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.TextureChangeSamplerFilter.res_id)
}

// required .NetworkPacket.SamplerType sampler_filter_type = 2;
bool TextureChangeSamplerFilter::has_sampler_filter_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void TextureChangeSamplerFilter::set_has_sampler_filter_type() {
  _has_bits_[0] |= 0x00000002u;
}
void TextureChangeSamplerFilter::clear_has_sampler_filter_type() {
  _has_bits_[0] &= ~0x00000002u;
}
void TextureChangeSamplerFilter::clear_sampler_filter_type() {
  sampler_filter_type_ = 1;
  clear_has_sampler_filter_type();
}
 ::NetworkPacket::SamplerType TextureChangeSamplerFilter::sampler_filter_type() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.TextureChangeSamplerFilter.sampler_filter_type)
  return static_cast< ::NetworkPacket::SamplerType >(sampler_filter_type_);
}
 void TextureChangeSamplerFilter::set_sampler_filter_type(::NetworkPacket::SamplerType value) {
  assert(::NetworkPacket::SamplerType_IsValid(value));
  set_has_sampler_filter_type();
  sampler_filter_type_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.TextureChangeSamplerFilter.sampler_filter_type)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForDeviceTexResources(
    DeviceTexResources* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int DeviceTexResources::kUidFieldNumber;
const int DeviceTexResources::kTexturesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

DeviceTexResources::DeviceTexResources()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:NetworkPacket.DeviceTexResources)
}

void DeviceTexResources::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  uid_ = const_cast< ::NetworkPacket::UID*>(
      ::NetworkPacket::UID::internal_default_instance());
#else
  uid_ = const_cast< ::NetworkPacket::UID*>(&::NetworkPacket::UID::default_instance());
#endif
}

DeviceTexResources::DeviceTexResources(const DeviceTexResources& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:NetworkPacket.DeviceTexResources)
}

void DeviceTexResources::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  uid_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DeviceTexResources::~DeviceTexResources() {
  // @@protoc_insertion_point(destructor:NetworkPacket.DeviceTexResources)
  SharedDtor();
}

void DeviceTexResources::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete uid_;
  }
}

void DeviceTexResources::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DeviceTexResources& DeviceTexResources::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_NetworkPacket_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_NetworkPacket_2eproto();
#endif
  return *default_instance_;
}

DeviceTexResources* DeviceTexResources::default_instance_ = NULL;

DeviceTexResources* DeviceTexResources::New(::google::protobuf::Arena* arena) const {
  DeviceTexResources* n = new DeviceTexResources;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void DeviceTexResources::Clear() {
// @@protoc_insertion_point(message_clear_start:NetworkPacket.DeviceTexResources)
  if (has_uid()) {
    if (uid_ != NULL) uid_->::NetworkPacket::UID::Clear();
  }
  textures_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool DeviceTexResources::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForDeviceTexResources, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:NetworkPacket.DeviceTexResources)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .NetworkPacket.UID uid = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_uid()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_textures;
        break;
      }

      // repeated .NetworkPacket.TextureResInfo textures = 2;
      case 2: {
        if (tag == 18) {
         parse_textures:
          DO_(input->IncrementRecursionDepth());
         parse_loop_textures:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_textures()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_loop_textures;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:NetworkPacket.DeviceTexResources)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:NetworkPacket.DeviceTexResources)
  return false;
#undef DO_
}

void DeviceTexResources::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:NetworkPacket.DeviceTexResources)
  // required .NetworkPacket.UID uid = 1;
  if (has_uid()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->uid_, output);
  }

  // repeated .NetworkPacket.TextureResInfo textures = 2;
  for (unsigned int i = 0, n = this->textures_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->textures(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:NetworkPacket.DeviceTexResources)
}

int DeviceTexResources::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:NetworkPacket.DeviceTexResources)
  int total_size = 0;

  // required .NetworkPacket.UID uid = 1;
  if (has_uid()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->uid_);
  }
  // repeated .NetworkPacket.TextureResInfo textures = 2;
  total_size += 1 * this->textures_size();
  for (int i = 0; i < this->textures_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->textures(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DeviceTexResources::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DeviceTexResources*>(&from));
}

void DeviceTexResources::MergeFrom(const DeviceTexResources& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:NetworkPacket.DeviceTexResources)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  textures_.MergeFrom(from.textures_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uid()) {
      mutable_uid()->::NetworkPacket::UID::MergeFrom(from.uid());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void DeviceTexResources::CopyFrom(const DeviceTexResources& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NetworkPacket.DeviceTexResources)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceTexResources::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_uid()) {
    if (!this->uid_->IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->textures())) return false;
  return true;
}

void DeviceTexResources::Swap(DeviceTexResources* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DeviceTexResources::InternalSwap(DeviceTexResources* other) {
  std::swap(uid_, other->uid_);
  textures_.UnsafeArenaSwap(&other->textures_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string DeviceTexResources::GetTypeName() const {
  return "NetworkPacket.DeviceTexResources";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// DeviceTexResources

// required .NetworkPacket.UID uid = 1;
bool DeviceTexResources::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void DeviceTexResources::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
void DeviceTexResources::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
void DeviceTexResources::clear_uid() {
  if (uid_ != NULL) uid_->::NetworkPacket::UID::Clear();
  clear_has_uid();
}
const ::NetworkPacket::UID& DeviceTexResources::uid() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.DeviceTexResources.uid)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return uid_ != NULL ? *uid_ : *default_instance().uid_;
#else
  return uid_ != NULL ? *uid_ : *default_instance_->uid_;
#endif
}
::NetworkPacket::UID* DeviceTexResources::mutable_uid() {
  set_has_uid();
  if (uid_ == NULL) {
    uid_ = new ::NetworkPacket::UID;
  }
  // @@protoc_insertion_point(field_mutable:NetworkPacket.DeviceTexResources.uid)
  return uid_;
}
::NetworkPacket::UID* DeviceTexResources::release_uid() {
  // @@protoc_insertion_point(field_release:NetworkPacket.DeviceTexResources.uid)
  clear_has_uid();
  ::NetworkPacket::UID* temp = uid_;
  uid_ = NULL;
  return temp;
}
void DeviceTexResources::set_allocated_uid(::NetworkPacket::UID* uid) {
  delete uid_;
  uid_ = uid;
  if (uid) {
    set_has_uid();
  } else {
    clear_has_uid();
  }
  // @@protoc_insertion_point(field_set_allocated:NetworkPacket.DeviceTexResources.uid)
}

// repeated .NetworkPacket.TextureResInfo textures = 2;
int DeviceTexResources::textures_size() const {
  return textures_.size();
}
void DeviceTexResources::clear_textures() {
  textures_.Clear();
}
const ::NetworkPacket::TextureResInfo& DeviceTexResources::textures(int index) const {
  // @@protoc_insertion_point(field_get:NetworkPacket.DeviceTexResources.textures)
  return textures_.Get(index);
}
::NetworkPacket::TextureResInfo* DeviceTexResources::mutable_textures(int index) {
  // @@protoc_insertion_point(field_mutable:NetworkPacket.DeviceTexResources.textures)
  return textures_.Mutable(index);
}
::NetworkPacket::TextureResInfo* DeviceTexResources::add_textures() {
  // @@protoc_insertion_point(field_add:NetworkPacket.DeviceTexResources.textures)
  return textures_.Add();
}
::google::protobuf::RepeatedPtrField< ::NetworkPacket::TextureResInfo >*
DeviceTexResources::mutable_textures() {
  // @@protoc_insertion_point(field_mutable_list:NetworkPacket.DeviceTexResources.textures)
  return &textures_;
}
const ::google::protobuf::RepeatedPtrField< ::NetworkPacket::TextureResInfo >&
DeviceTexResources::textures() const {
  // @@protoc_insertion_point(field_list:NetworkPacket.DeviceTexResources.textures)
  return textures_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForDeviceMemResInfo(
    DeviceMemResInfo* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int DeviceMemResInfo::kFileNameFieldNumber;
const int DeviceMemResInfo::kLineNumberFieldNumber;
const int DeviceMemResInfo::kSizeInBytesFieldNumber;
const int DeviceMemResInfo::kNumberFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

DeviceMemResInfo::DeviceMemResInfo()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:NetworkPacket.DeviceMemResInfo)
}

void DeviceMemResInfo::InitAsDefaultInstance() {
}

DeviceMemResInfo::DeviceMemResInfo(const DeviceMemResInfo& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:NetworkPacket.DeviceMemResInfo)
}

void DeviceMemResInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  file_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  line_number_ = 0u;
  size_in_bytes_ = 0u;
  number_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DeviceMemResInfo::~DeviceMemResInfo() {
  // @@protoc_insertion_point(destructor:NetworkPacket.DeviceMemResInfo)
  SharedDtor();
}

void DeviceMemResInfo::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  file_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void DeviceMemResInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DeviceMemResInfo& DeviceMemResInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_NetworkPacket_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_NetworkPacket_2eproto();
#endif
  return *default_instance_;
}

DeviceMemResInfo* DeviceMemResInfo::default_instance_ = NULL;

DeviceMemResInfo* DeviceMemResInfo::New(::google::protobuf::Arena* arena) const {
  DeviceMemResInfo* n = new DeviceMemResInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void DeviceMemResInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:NetworkPacket.DeviceMemResInfo)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(DeviceMemResInfo, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<DeviceMemResInfo*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 15u) {
    ZR_(line_number_, number_);
    if (has_file_name()) {
      file_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool DeviceMemResInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForDeviceMemResInfo, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:NetworkPacket.DeviceMemResInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string file_name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_file_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_line_number;
        break;
      }

      // required uint32 line_number = 2;
      case 2: {
        if (tag == 16) {
         parse_line_number:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &line_number_)));
          set_has_line_number();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_size_in_bytes;
        break;
      }

      // required uint32 size_in_bytes = 3;
      case 3: {
        if (tag == 24) {
         parse_size_in_bytes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &size_in_bytes_)));
          set_has_size_in_bytes();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_number;
        break;
      }

      // optional uint32 number = 4;
      case 4: {
        if (tag == 32) {
         parse_number:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &number_)));
          set_has_number();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:NetworkPacket.DeviceMemResInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:NetworkPacket.DeviceMemResInfo)
  return false;
#undef DO_
}

void DeviceMemResInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:NetworkPacket.DeviceMemResInfo)
  // required string file_name = 1;
  if (has_file_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->file_name(), output);
  }

  // required uint32 line_number = 2;
  if (has_line_number()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->line_number(), output);
  }

  // required uint32 size_in_bytes = 3;
  if (has_size_in_bytes()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->size_in_bytes(), output);
  }

  // optional uint32 number = 4;
  if (has_number()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->number(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:NetworkPacket.DeviceMemResInfo)
}

int DeviceMemResInfo::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:NetworkPacket.DeviceMemResInfo)
  int total_size = 0;

  if (has_file_name()) {
    // required string file_name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->file_name());
  }

  if (has_line_number()) {
    // required uint32 line_number = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->line_number());
  }

  if (has_size_in_bytes()) {
    // required uint32 size_in_bytes = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->size_in_bytes());
  }

  return total_size;
}
int DeviceMemResInfo::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:NetworkPacket.DeviceMemResInfo)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required string file_name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->file_name());

    // required uint32 line_number = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->line_number());

    // required uint32 size_in_bytes = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->size_in_bytes());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  // optional uint32 number = 4;
  if (has_number()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->number());
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DeviceMemResInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DeviceMemResInfo*>(&from));
}

void DeviceMemResInfo::MergeFrom(const DeviceMemResInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:NetworkPacket.DeviceMemResInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_file_name()) {
      set_has_file_name();
      file_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.file_name_);
    }
    if (from.has_line_number()) {
      set_line_number(from.line_number());
    }
    if (from.has_size_in_bytes()) {
      set_size_in_bytes(from.size_in_bytes());
    }
    if (from.has_number()) {
      set_number(from.number());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void DeviceMemResInfo::CopyFrom(const DeviceMemResInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NetworkPacket.DeviceMemResInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceMemResInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void DeviceMemResInfo::Swap(DeviceMemResInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DeviceMemResInfo::InternalSwap(DeviceMemResInfo* other) {
  file_name_.Swap(&other->file_name_);
  std::swap(line_number_, other->line_number_);
  std::swap(size_in_bytes_, other->size_in_bytes_);
  std::swap(number_, other->number_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string DeviceMemResInfo::GetTypeName() const {
  return "NetworkPacket.DeviceMemResInfo";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// DeviceMemResInfo

// required string file_name = 1;
bool DeviceMemResInfo::has_file_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void DeviceMemResInfo::set_has_file_name() {
  _has_bits_[0] |= 0x00000001u;
}
void DeviceMemResInfo::clear_has_file_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void DeviceMemResInfo::clear_file_name() {
  file_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_file_name();
}
 const ::std::string& DeviceMemResInfo::file_name() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.DeviceMemResInfo.file_name)
  return file_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void DeviceMemResInfo::set_file_name(const ::std::string& value) {
  set_has_file_name();
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NetworkPacket.DeviceMemResInfo.file_name)
}
 void DeviceMemResInfo::set_file_name(const char* value) {
  set_has_file_name();
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NetworkPacket.DeviceMemResInfo.file_name)
}
 void DeviceMemResInfo::set_file_name(const char* value, size_t size) {
  set_has_file_name();
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NetworkPacket.DeviceMemResInfo.file_name)
}
 ::std::string* DeviceMemResInfo::mutable_file_name() {
  set_has_file_name();
  // @@protoc_insertion_point(field_mutable:NetworkPacket.DeviceMemResInfo.file_name)
  return file_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* DeviceMemResInfo::release_file_name() {
  // @@protoc_insertion_point(field_release:NetworkPacket.DeviceMemResInfo.file_name)
  clear_has_file_name();
  return file_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void DeviceMemResInfo::set_allocated_file_name(::std::string* file_name) {
  if (file_name != NULL) {
    set_has_file_name();
  } else {
    clear_has_file_name();
  }
  file_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), file_name);
  // @@protoc_insertion_point(field_set_allocated:NetworkPacket.DeviceMemResInfo.file_name)
}

// required uint32 line_number = 2;
bool DeviceMemResInfo::has_line_number() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void DeviceMemResInfo::set_has_line_number() {
  _has_bits_[0] |= 0x00000002u;
}
void DeviceMemResInfo::clear_has_line_number() {
  _has_bits_[0] &= ~0x00000002u;
}
void DeviceMemResInfo::clear_line_number() {
  line_number_ = 0u;
  clear_has_line_number();
}
 ::google::protobuf::uint32 DeviceMemResInfo::line_number() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.DeviceMemResInfo.line_number)
  return line_number_;
}
 void DeviceMemResInfo::set_line_number(::google::protobuf::uint32 value) {
  set_has_line_number();
  line_number_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.DeviceMemResInfo.line_number)
}

// required uint32 size_in_bytes = 3;
bool DeviceMemResInfo::has_size_in_bytes() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void DeviceMemResInfo::set_has_size_in_bytes() {
  _has_bits_[0] |= 0x00000004u;
}
void DeviceMemResInfo::clear_has_size_in_bytes() {
  _has_bits_[0] &= ~0x00000004u;
}
void DeviceMemResInfo::clear_size_in_bytes() {
  size_in_bytes_ = 0u;
  clear_has_size_in_bytes();
}
 ::google::protobuf::uint32 DeviceMemResInfo::size_in_bytes() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.DeviceMemResInfo.size_in_bytes)
  return size_in_bytes_;
}
 void DeviceMemResInfo::set_size_in_bytes(::google::protobuf::uint32 value) {
  set_has_size_in_bytes();
  size_in_bytes_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.DeviceMemResInfo.size_in_bytes)
}

// optional uint32 number = 4;
bool DeviceMemResInfo::has_number() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void DeviceMemResInfo::set_has_number() {
  _has_bits_[0] |= 0x00000008u;
}
void DeviceMemResInfo::clear_has_number() {
  _has_bits_[0] &= ~0x00000008u;
}
void DeviceMemResInfo::clear_number() {
  number_ = 0u;
  clear_has_number();
}
 ::google::protobuf::uint32 DeviceMemResInfo::number() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.DeviceMemResInfo.number)
  return number_;
}
 void DeviceMemResInfo::set_number(::google::protobuf::uint32 value) {
  set_has_number();
  number_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.DeviceMemResInfo.number)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForDeviceMemResources(
    DeviceMemResources* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int DeviceMemResources::kUidFieldNumber;
const int DeviceMemResources::kMinSizeFieldNumber;
const int DeviceMemResources::kTotalAllocSizeFieldNumber;
const int DeviceMemResources::kTotalAllocNumberFieldNumber;
const int DeviceMemResources::kResourcesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

DeviceMemResources::DeviceMemResources()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:NetworkPacket.DeviceMemResources)
}

void DeviceMemResources::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  uid_ = const_cast< ::NetworkPacket::UID*>(
      ::NetworkPacket::UID::internal_default_instance());
#else
  uid_ = const_cast< ::NetworkPacket::UID*>(&::NetworkPacket::UID::default_instance());
#endif
}

DeviceMemResources::DeviceMemResources(const DeviceMemResources& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:NetworkPacket.DeviceMemResources)
}

void DeviceMemResources::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  uid_ = NULL;
  min_size_ = 0u;
  total_alloc_size_ = 0u;
  total_alloc_number_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DeviceMemResources::~DeviceMemResources() {
  // @@protoc_insertion_point(destructor:NetworkPacket.DeviceMemResources)
  SharedDtor();
}

void DeviceMemResources::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete uid_;
  }
}

void DeviceMemResources::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DeviceMemResources& DeviceMemResources::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_NetworkPacket_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_NetworkPacket_2eproto();
#endif
  return *default_instance_;
}

DeviceMemResources* DeviceMemResources::default_instance_ = NULL;

DeviceMemResources* DeviceMemResources::New(::google::protobuf::Arena* arena) const {
  DeviceMemResources* n = new DeviceMemResources;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void DeviceMemResources::Clear() {
// @@protoc_insertion_point(message_clear_start:NetworkPacket.DeviceMemResources)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(DeviceMemResources, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<DeviceMemResources*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 15u) {
    ZR_(min_size_, total_alloc_size_);
    if (has_uid()) {
      if (uid_ != NULL) uid_->::NetworkPacket::UID::Clear();
    }
    total_alloc_number_ = 0u;
  }

#undef ZR_HELPER_
#undef ZR_

  resources_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool DeviceMemResources::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForDeviceMemResources, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:NetworkPacket.DeviceMemResources)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .NetworkPacket.UID uid = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_uid()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_min_size;
        break;
      }

      // optional uint32 min_size = 2;
      case 2: {
        if (tag == 16) {
         parse_min_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &min_size_)));
          set_has_min_size();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_total_alloc_size;
        break;
      }

      // optional uint32 total_alloc_size = 3;
      case 3: {
        if (tag == 24) {
         parse_total_alloc_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &total_alloc_size_)));
          set_has_total_alloc_size();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_total_alloc_number;
        break;
      }

      // optional uint32 total_alloc_number = 4;
      case 4: {
        if (tag == 32) {
         parse_total_alloc_number:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &total_alloc_number_)));
          set_has_total_alloc_number();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_resources;
        break;
      }

      // repeated .NetworkPacket.DeviceMemResInfo resources = 5;
      case 5: {
        if (tag == 42) {
         parse_resources:
          DO_(input->IncrementRecursionDepth());
         parse_loop_resources:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_resources()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_loop_resources;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:NetworkPacket.DeviceMemResources)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:NetworkPacket.DeviceMemResources)
  return false;
#undef DO_
}

void DeviceMemResources::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:NetworkPacket.DeviceMemResources)
  // optional .NetworkPacket.UID uid = 1;
  if (has_uid()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->uid_, output);
  }

  // optional uint32 min_size = 2;
  if (has_min_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->min_size(), output);
  }

  // optional uint32 total_alloc_size = 3;
  if (has_total_alloc_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->total_alloc_size(), output);
  }

  // optional uint32 total_alloc_number = 4;
  if (has_total_alloc_number()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->total_alloc_number(), output);
  }

  // repeated .NetworkPacket.DeviceMemResInfo resources = 5;
  for (unsigned int i = 0, n = this->resources_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, this->resources(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:NetworkPacket.DeviceMemResources)
}

int DeviceMemResources::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:NetworkPacket.DeviceMemResources)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 15u) {
    // optional .NetworkPacket.UID uid = 1;
    if (has_uid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->uid_);
    }

    // optional uint32 min_size = 2;
    if (has_min_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->min_size());
    }

    // optional uint32 total_alloc_size = 3;
    if (has_total_alloc_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->total_alloc_size());
    }

    // optional uint32 total_alloc_number = 4;
    if (has_total_alloc_number()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->total_alloc_number());
    }

  }
  // repeated .NetworkPacket.DeviceMemResInfo resources = 5;
  total_size += 1 * this->resources_size();
  for (int i = 0; i < this->resources_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->resources(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DeviceMemResources::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DeviceMemResources*>(&from));
}

void DeviceMemResources::MergeFrom(const DeviceMemResources& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:NetworkPacket.DeviceMemResources)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  resources_.MergeFrom(from.resources_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uid()) {
      mutable_uid()->::NetworkPacket::UID::MergeFrom(from.uid());
    }
    if (from.has_min_size()) {
      set_min_size(from.min_size());
    }
    if (from.has_total_alloc_size()) {
      set_total_alloc_size(from.total_alloc_size());
    }
    if (from.has_total_alloc_number()) {
      set_total_alloc_number(from.total_alloc_number());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void DeviceMemResources::CopyFrom(const DeviceMemResources& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NetworkPacket.DeviceMemResources)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceMemResources::IsInitialized() const {

  if (has_uid()) {
    if (!this->uid_->IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->resources())) return false;
  return true;
}

void DeviceMemResources::Swap(DeviceMemResources* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DeviceMemResources::InternalSwap(DeviceMemResources* other) {
  std::swap(uid_, other->uid_);
  std::swap(min_size_, other->min_size_);
  std::swap(total_alloc_size_, other->total_alloc_size_);
  std::swap(total_alloc_number_, other->total_alloc_number_);
  resources_.UnsafeArenaSwap(&other->resources_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string DeviceMemResources::GetTypeName() const {
  return "NetworkPacket.DeviceMemResources";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// DeviceMemResources

// optional .NetworkPacket.UID uid = 1;
bool DeviceMemResources::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void DeviceMemResources::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
void DeviceMemResources::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
void DeviceMemResources::clear_uid() {
  if (uid_ != NULL) uid_->::NetworkPacket::UID::Clear();
  clear_has_uid();
}
const ::NetworkPacket::UID& DeviceMemResources::uid() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.DeviceMemResources.uid)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return uid_ != NULL ? *uid_ : *default_instance().uid_;
#else
  return uid_ != NULL ? *uid_ : *default_instance_->uid_;
#endif
}
::NetworkPacket::UID* DeviceMemResources::mutable_uid() {
  set_has_uid();
  if (uid_ == NULL) {
    uid_ = new ::NetworkPacket::UID;
  }
  // @@protoc_insertion_point(field_mutable:NetworkPacket.DeviceMemResources.uid)
  return uid_;
}
::NetworkPacket::UID* DeviceMemResources::release_uid() {
  // @@protoc_insertion_point(field_release:NetworkPacket.DeviceMemResources.uid)
  clear_has_uid();
  ::NetworkPacket::UID* temp = uid_;
  uid_ = NULL;
  return temp;
}
void DeviceMemResources::set_allocated_uid(::NetworkPacket::UID* uid) {
  delete uid_;
  uid_ = uid;
  if (uid) {
    set_has_uid();
  } else {
    clear_has_uid();
  }
  // @@protoc_insertion_point(field_set_allocated:NetworkPacket.DeviceMemResources.uid)
}

// optional uint32 min_size = 2;
bool DeviceMemResources::has_min_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void DeviceMemResources::set_has_min_size() {
  _has_bits_[0] |= 0x00000002u;
}
void DeviceMemResources::clear_has_min_size() {
  _has_bits_[0] &= ~0x00000002u;
}
void DeviceMemResources::clear_min_size() {
  min_size_ = 0u;
  clear_has_min_size();
}
 ::google::protobuf::uint32 DeviceMemResources::min_size() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.DeviceMemResources.min_size)
  return min_size_;
}
 void DeviceMemResources::set_min_size(::google::protobuf::uint32 value) {
  set_has_min_size();
  min_size_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.DeviceMemResources.min_size)
}

// optional uint32 total_alloc_size = 3;
bool DeviceMemResources::has_total_alloc_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void DeviceMemResources::set_has_total_alloc_size() {
  _has_bits_[0] |= 0x00000004u;
}
void DeviceMemResources::clear_has_total_alloc_size() {
  _has_bits_[0] &= ~0x00000004u;
}
void DeviceMemResources::clear_total_alloc_size() {
  total_alloc_size_ = 0u;
  clear_has_total_alloc_size();
}
 ::google::protobuf::uint32 DeviceMemResources::total_alloc_size() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.DeviceMemResources.total_alloc_size)
  return total_alloc_size_;
}
 void DeviceMemResources::set_total_alloc_size(::google::protobuf::uint32 value) {
  set_has_total_alloc_size();
  total_alloc_size_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.DeviceMemResources.total_alloc_size)
}

// optional uint32 total_alloc_number = 4;
bool DeviceMemResources::has_total_alloc_number() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void DeviceMemResources::set_has_total_alloc_number() {
  _has_bits_[0] |= 0x00000008u;
}
void DeviceMemResources::clear_has_total_alloc_number() {
  _has_bits_[0] &= ~0x00000008u;
}
void DeviceMemResources::clear_total_alloc_number() {
  total_alloc_number_ = 0u;
  clear_has_total_alloc_number();
}
 ::google::protobuf::uint32 DeviceMemResources::total_alloc_number() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.DeviceMemResources.total_alloc_number)
  return total_alloc_number_;
}
 void DeviceMemResources::set_total_alloc_number(::google::protobuf::uint32 value) {
  set_has_total_alloc_number();
  total_alloc_number_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.DeviceMemResources.total_alloc_number)
}

// repeated .NetworkPacket.DeviceMemResInfo resources = 5;
int DeviceMemResources::resources_size() const {
  return resources_.size();
}
void DeviceMemResources::clear_resources() {
  resources_.Clear();
}
const ::NetworkPacket::DeviceMemResInfo& DeviceMemResources::resources(int index) const {
  // @@protoc_insertion_point(field_get:NetworkPacket.DeviceMemResources.resources)
  return resources_.Get(index);
}
::NetworkPacket::DeviceMemResInfo* DeviceMemResources::mutable_resources(int index) {
  // @@protoc_insertion_point(field_mutable:NetworkPacket.DeviceMemResources.resources)
  return resources_.Mutable(index);
}
::NetworkPacket::DeviceMemResInfo* DeviceMemResources::add_resources() {
  // @@protoc_insertion_point(field_add:NetworkPacket.DeviceMemResources.resources)
  return resources_.Add();
}
::google::protobuf::RepeatedPtrField< ::NetworkPacket::DeviceMemResInfo >*
DeviceMemResources::mutable_resources() {
  // @@protoc_insertion_point(field_mutable_list:NetworkPacket.DeviceMemResources.resources)
  return &resources_;
}
const ::google::protobuf::RepeatedPtrField< ::NetworkPacket::DeviceMemResInfo >&
DeviceMemResources::resources() const {
  // @@protoc_insertion_point(field_list:NetworkPacket.DeviceMemResources.resources)
  return resources_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForShaderResInfo(
    ShaderResInfo* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ShaderResInfo::kNameFieldNumber;
const int ShaderResInfo::kKeyFieldNumber;
const int ShaderResInfo::kVsCodeFieldNumber;
const int ShaderResInfo::kPsCodeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ShaderResInfo::ShaderResInfo()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:NetworkPacket.ShaderResInfo)
}

void ShaderResInfo::InitAsDefaultInstance() {
}

ShaderResInfo::ShaderResInfo(const ShaderResInfo& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:NetworkPacket.ShaderResInfo)
}

void ShaderResInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  key_ = 0u;
  vs_code_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ps_code_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ShaderResInfo::~ShaderResInfo() {
  // @@protoc_insertion_point(destructor:NetworkPacket.ShaderResInfo)
  SharedDtor();
}

void ShaderResInfo::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  vs_code_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ps_code_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ShaderResInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ShaderResInfo& ShaderResInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_NetworkPacket_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_NetworkPacket_2eproto();
#endif
  return *default_instance_;
}

ShaderResInfo* ShaderResInfo::default_instance_ = NULL;

ShaderResInfo* ShaderResInfo::New(::google::protobuf::Arena* arena) const {
  ShaderResInfo* n = new ShaderResInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ShaderResInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:NetworkPacket.ShaderResInfo)
  if (_has_bits_[0 / 32] & 15u) {
    if (has_name()) {
      name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    key_ = 0u;
    if (has_vs_code()) {
      vs_code_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_ps_code()) {
      ps_code_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool ShaderResInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForShaderResInfo, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:NetworkPacket.ShaderResInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_key;
        break;
      }

      // required uint32 key = 2;
      case 2: {
        if (tag == 16) {
         parse_key:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &key_)));
          set_has_key();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_vs_code;
        break;
      }

      // required string vs_code = 3;
      case 3: {
        if (tag == 26) {
         parse_vs_code:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_vs_code()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_ps_code;
        break;
      }

      // required string ps_code = 4;
      case 4: {
        if (tag == 34) {
         parse_ps_code:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_ps_code()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:NetworkPacket.ShaderResInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:NetworkPacket.ShaderResInfo)
  return false;
#undef DO_
}

void ShaderResInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:NetworkPacket.ShaderResInfo)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // required uint32 key = 2;
  if (has_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->key(), output);
  }

  // required string vs_code = 3;
  if (has_vs_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->vs_code(), output);
  }

  // required string ps_code = 4;
  if (has_ps_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->ps_code(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:NetworkPacket.ShaderResInfo)
}

int ShaderResInfo::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:NetworkPacket.ShaderResInfo)
  int total_size = 0;

  if (has_name()) {
    // required string name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->name());
  }

  if (has_key()) {
    // required uint32 key = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->key());
  }

  if (has_vs_code()) {
    // required string vs_code = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->vs_code());
  }

  if (has_ps_code()) {
    // required string ps_code = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->ps_code());
  }

  return total_size;
}
int ShaderResInfo::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:NetworkPacket.ShaderResInfo)
  int total_size = 0;

  if (((_has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required string name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->name());

    // required uint32 key = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->key());

    // required string vs_code = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->vs_code());

    // required string ps_code = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->ps_code());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ShaderResInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ShaderResInfo*>(&from));
}

void ShaderResInfo::MergeFrom(const ShaderResInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:NetworkPacket.ShaderResInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_has_name();
      name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (from.has_key()) {
      set_key(from.key());
    }
    if (from.has_vs_code()) {
      set_has_vs_code();
      vs_code_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.vs_code_);
    }
    if (from.has_ps_code()) {
      set_has_ps_code();
      ps_code_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.ps_code_);
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void ShaderResInfo::CopyFrom(const ShaderResInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NetworkPacket.ShaderResInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShaderResInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void ShaderResInfo::Swap(ShaderResInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ShaderResInfo::InternalSwap(ShaderResInfo* other) {
  name_.Swap(&other->name_);
  std::swap(key_, other->key_);
  vs_code_.Swap(&other->vs_code_);
  ps_code_.Swap(&other->ps_code_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string ShaderResInfo::GetTypeName() const {
  return "NetworkPacket.ShaderResInfo";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ShaderResInfo

// required string name = 1;
bool ShaderResInfo::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ShaderResInfo::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
void ShaderResInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void ShaderResInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
 const ::std::string& ShaderResInfo::name() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.ShaderResInfo.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ShaderResInfo::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NetworkPacket.ShaderResInfo.name)
}
 void ShaderResInfo::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NetworkPacket.ShaderResInfo.name)
}
 void ShaderResInfo::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NetworkPacket.ShaderResInfo.name)
}
 ::std::string* ShaderResInfo::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:NetworkPacket.ShaderResInfo.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* ShaderResInfo::release_name() {
  // @@protoc_insertion_point(field_release:NetworkPacket.ShaderResInfo.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ShaderResInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:NetworkPacket.ShaderResInfo.name)
}

// required uint32 key = 2;
bool ShaderResInfo::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ShaderResInfo::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
void ShaderResInfo::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
void ShaderResInfo::clear_key() {
  key_ = 0u;
  clear_has_key();
}
 ::google::protobuf::uint32 ShaderResInfo::key() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.ShaderResInfo.key)
  return key_;
}
 void ShaderResInfo::set_key(::google::protobuf::uint32 value) {
  set_has_key();
  key_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.ShaderResInfo.key)
}

// required string vs_code = 3;
bool ShaderResInfo::has_vs_code() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void ShaderResInfo::set_has_vs_code() {
  _has_bits_[0] |= 0x00000004u;
}
void ShaderResInfo::clear_has_vs_code() {
  _has_bits_[0] &= ~0x00000004u;
}
void ShaderResInfo::clear_vs_code() {
  vs_code_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_vs_code();
}
 const ::std::string& ShaderResInfo::vs_code() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.ShaderResInfo.vs_code)
  return vs_code_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ShaderResInfo::set_vs_code(const ::std::string& value) {
  set_has_vs_code();
  vs_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NetworkPacket.ShaderResInfo.vs_code)
}
 void ShaderResInfo::set_vs_code(const char* value) {
  set_has_vs_code();
  vs_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NetworkPacket.ShaderResInfo.vs_code)
}
 void ShaderResInfo::set_vs_code(const char* value, size_t size) {
  set_has_vs_code();
  vs_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NetworkPacket.ShaderResInfo.vs_code)
}
 ::std::string* ShaderResInfo::mutable_vs_code() {
  set_has_vs_code();
  // @@protoc_insertion_point(field_mutable:NetworkPacket.ShaderResInfo.vs_code)
  return vs_code_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* ShaderResInfo::release_vs_code() {
  // @@protoc_insertion_point(field_release:NetworkPacket.ShaderResInfo.vs_code)
  clear_has_vs_code();
  return vs_code_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ShaderResInfo::set_allocated_vs_code(::std::string* vs_code) {
  if (vs_code != NULL) {
    set_has_vs_code();
  } else {
    clear_has_vs_code();
  }
  vs_code_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), vs_code);
  // @@protoc_insertion_point(field_set_allocated:NetworkPacket.ShaderResInfo.vs_code)
}

// required string ps_code = 4;
bool ShaderResInfo::has_ps_code() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void ShaderResInfo::set_has_ps_code() {
  _has_bits_[0] |= 0x00000008u;
}
void ShaderResInfo::clear_has_ps_code() {
  _has_bits_[0] &= ~0x00000008u;
}
void ShaderResInfo::clear_ps_code() {
  ps_code_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ps_code();
}
 const ::std::string& ShaderResInfo::ps_code() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.ShaderResInfo.ps_code)
  return ps_code_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ShaderResInfo::set_ps_code(const ::std::string& value) {
  set_has_ps_code();
  ps_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NetworkPacket.ShaderResInfo.ps_code)
}
 void ShaderResInfo::set_ps_code(const char* value) {
  set_has_ps_code();
  ps_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NetworkPacket.ShaderResInfo.ps_code)
}
 void ShaderResInfo::set_ps_code(const char* value, size_t size) {
  set_has_ps_code();
  ps_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NetworkPacket.ShaderResInfo.ps_code)
}
 ::std::string* ShaderResInfo::mutable_ps_code() {
  set_has_ps_code();
  // @@protoc_insertion_point(field_mutable:NetworkPacket.ShaderResInfo.ps_code)
  return ps_code_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* ShaderResInfo::release_ps_code() {
  // @@protoc_insertion_point(field_release:NetworkPacket.ShaderResInfo.ps_code)
  clear_has_ps_code();
  return ps_code_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ShaderResInfo::set_allocated_ps_code(::std::string* ps_code) {
  if (ps_code != NULL) {
    set_has_ps_code();
  } else {
    clear_has_ps_code();
  }
  ps_code_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ps_code);
  // @@protoc_insertion_point(field_set_allocated:NetworkPacket.ShaderResInfo.ps_code)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForDeviceShaderResources(
    DeviceShaderResources* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int DeviceShaderResources::kUidFieldNumber;
const int DeviceShaderResources::kShadersFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

DeviceShaderResources::DeviceShaderResources()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:NetworkPacket.DeviceShaderResources)
}

void DeviceShaderResources::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  uid_ = const_cast< ::NetworkPacket::UID*>(
      ::NetworkPacket::UID::internal_default_instance());
#else
  uid_ = const_cast< ::NetworkPacket::UID*>(&::NetworkPacket::UID::default_instance());
#endif
}

DeviceShaderResources::DeviceShaderResources(const DeviceShaderResources& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:NetworkPacket.DeviceShaderResources)
}

void DeviceShaderResources::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  uid_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DeviceShaderResources::~DeviceShaderResources() {
  // @@protoc_insertion_point(destructor:NetworkPacket.DeviceShaderResources)
  SharedDtor();
}

void DeviceShaderResources::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete uid_;
  }
}

void DeviceShaderResources::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DeviceShaderResources& DeviceShaderResources::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_NetworkPacket_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_NetworkPacket_2eproto();
#endif
  return *default_instance_;
}

DeviceShaderResources* DeviceShaderResources::default_instance_ = NULL;

DeviceShaderResources* DeviceShaderResources::New(::google::protobuf::Arena* arena) const {
  DeviceShaderResources* n = new DeviceShaderResources;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void DeviceShaderResources::Clear() {
// @@protoc_insertion_point(message_clear_start:NetworkPacket.DeviceShaderResources)
  if (has_uid()) {
    if (uid_ != NULL) uid_->::NetworkPacket::UID::Clear();
  }
  shaders_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool DeviceShaderResources::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForDeviceShaderResources, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:NetworkPacket.DeviceShaderResources)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .NetworkPacket.UID uid = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_uid()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_shaders;
        break;
      }

      // repeated .NetworkPacket.ShaderResInfo shaders = 2;
      case 2: {
        if (tag == 18) {
         parse_shaders:
          DO_(input->IncrementRecursionDepth());
         parse_loop_shaders:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_shaders()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_loop_shaders;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:NetworkPacket.DeviceShaderResources)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:NetworkPacket.DeviceShaderResources)
  return false;
#undef DO_
}

void DeviceShaderResources::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:NetworkPacket.DeviceShaderResources)
  // required .NetworkPacket.UID uid = 1;
  if (has_uid()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->uid_, output);
  }

  // repeated .NetworkPacket.ShaderResInfo shaders = 2;
  for (unsigned int i = 0, n = this->shaders_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->shaders(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:NetworkPacket.DeviceShaderResources)
}

int DeviceShaderResources::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:NetworkPacket.DeviceShaderResources)
  int total_size = 0;

  // required .NetworkPacket.UID uid = 1;
  if (has_uid()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->uid_);
  }
  // repeated .NetworkPacket.ShaderResInfo shaders = 2;
  total_size += 1 * this->shaders_size();
  for (int i = 0; i < this->shaders_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->shaders(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DeviceShaderResources::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DeviceShaderResources*>(&from));
}

void DeviceShaderResources::MergeFrom(const DeviceShaderResources& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:NetworkPacket.DeviceShaderResources)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  shaders_.MergeFrom(from.shaders_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uid()) {
      mutable_uid()->::NetworkPacket::UID::MergeFrom(from.uid());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void DeviceShaderResources::CopyFrom(const DeviceShaderResources& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NetworkPacket.DeviceShaderResources)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceShaderResources::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_uid()) {
    if (!this->uid_->IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->shaders())) return false;
  return true;
}

void DeviceShaderResources::Swap(DeviceShaderResources* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DeviceShaderResources::InternalSwap(DeviceShaderResources* other) {
  std::swap(uid_, other->uid_);
  shaders_.UnsafeArenaSwap(&other->shaders_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string DeviceShaderResources::GetTypeName() const {
  return "NetworkPacket.DeviceShaderResources";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// DeviceShaderResources

// required .NetworkPacket.UID uid = 1;
bool DeviceShaderResources::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void DeviceShaderResources::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
void DeviceShaderResources::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
void DeviceShaderResources::clear_uid() {
  if (uid_ != NULL) uid_->::NetworkPacket::UID::Clear();
  clear_has_uid();
}
const ::NetworkPacket::UID& DeviceShaderResources::uid() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.DeviceShaderResources.uid)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return uid_ != NULL ? *uid_ : *default_instance().uid_;
#else
  return uid_ != NULL ? *uid_ : *default_instance_->uid_;
#endif
}
::NetworkPacket::UID* DeviceShaderResources::mutable_uid() {
  set_has_uid();
  if (uid_ == NULL) {
    uid_ = new ::NetworkPacket::UID;
  }
  // @@protoc_insertion_point(field_mutable:NetworkPacket.DeviceShaderResources.uid)
  return uid_;
}
::NetworkPacket::UID* DeviceShaderResources::release_uid() {
  // @@protoc_insertion_point(field_release:NetworkPacket.DeviceShaderResources.uid)
  clear_has_uid();
  ::NetworkPacket::UID* temp = uid_;
  uid_ = NULL;
  return temp;
}
void DeviceShaderResources::set_allocated_uid(::NetworkPacket::UID* uid) {
  delete uid_;
  uid_ = uid;
  if (uid) {
    set_has_uid();
  } else {
    clear_has_uid();
  }
  // @@protoc_insertion_point(field_set_allocated:NetworkPacket.DeviceShaderResources.uid)
}

// repeated .NetworkPacket.ShaderResInfo shaders = 2;
int DeviceShaderResources::shaders_size() const {
  return shaders_.size();
}
void DeviceShaderResources::clear_shaders() {
  shaders_.Clear();
}
const ::NetworkPacket::ShaderResInfo& DeviceShaderResources::shaders(int index) const {
  // @@protoc_insertion_point(field_get:NetworkPacket.DeviceShaderResources.shaders)
  return shaders_.Get(index);
}
::NetworkPacket::ShaderResInfo* DeviceShaderResources::mutable_shaders(int index) {
  // @@protoc_insertion_point(field_mutable:NetworkPacket.DeviceShaderResources.shaders)
  return shaders_.Mutable(index);
}
::NetworkPacket::ShaderResInfo* DeviceShaderResources::add_shaders() {
  // @@protoc_insertion_point(field_add:NetworkPacket.DeviceShaderResources.shaders)
  return shaders_.Add();
}
::google::protobuf::RepeatedPtrField< ::NetworkPacket::ShaderResInfo >*
DeviceShaderResources::mutable_shaders() {
  // @@protoc_insertion_point(field_mutable_list:NetworkPacket.DeviceShaderResources.shaders)
  return &shaders_;
}
const ::google::protobuf::RepeatedPtrField< ::NetworkPacket::ShaderResInfo >&
DeviceShaderResources::shaders() const {
  // @@protoc_insertion_point(field_list:NetworkPacket.DeviceShaderResources.shaders)
  return shaders_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForGUIResInfo(
    GUIResInfo* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int GUIResInfo::kGuiControlsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GUIResInfo::GUIResInfo()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:NetworkPacket.GUIResInfo)
}

void GUIResInfo::InitAsDefaultInstance() {
}

GUIResInfo::GUIResInfo(const GUIResInfo& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:NetworkPacket.GUIResInfo)
}

void GUIResInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  gui_controls_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GUIResInfo::~GUIResInfo() {
  // @@protoc_insertion_point(destructor:NetworkPacket.GUIResInfo)
  SharedDtor();
}

void GUIResInfo::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  gui_controls_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GUIResInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GUIResInfo& GUIResInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_NetworkPacket_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_NetworkPacket_2eproto();
#endif
  return *default_instance_;
}

GUIResInfo* GUIResInfo::default_instance_ = NULL;

GUIResInfo* GUIResInfo::New(::google::protobuf::Arena* arena) const {
  GUIResInfo* n = new GUIResInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void GUIResInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:NetworkPacket.GUIResInfo)
  if (has_gui_controls()) {
    gui_controls_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool GUIResInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForGUIResInfo, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:NetworkPacket.GUIResInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string gui_controls = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_gui_controls()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:NetworkPacket.GUIResInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:NetworkPacket.GUIResInfo)
  return false;
#undef DO_
}

void GUIResInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:NetworkPacket.GUIResInfo)
  // required string gui_controls = 1;
  if (has_gui_controls()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->gui_controls(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:NetworkPacket.GUIResInfo)
}

int GUIResInfo::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:NetworkPacket.GUIResInfo)
  int total_size = 0;

  // required string gui_controls = 1;
  if (has_gui_controls()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->gui_controls());
  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GUIResInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GUIResInfo*>(&from));
}

void GUIResInfo::MergeFrom(const GUIResInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:NetworkPacket.GUIResInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_gui_controls()) {
      set_has_gui_controls();
      gui_controls_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.gui_controls_);
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void GUIResInfo::CopyFrom(const GUIResInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NetworkPacket.GUIResInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GUIResInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void GUIResInfo::Swap(GUIResInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GUIResInfo::InternalSwap(GUIResInfo* other) {
  gui_controls_.Swap(&other->gui_controls_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string GUIResInfo::GetTypeName() const {
  return "NetworkPacket.GUIResInfo";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// GUIResInfo

// required string gui_controls = 1;
bool GUIResInfo::has_gui_controls() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void GUIResInfo::set_has_gui_controls() {
  _has_bits_[0] |= 0x00000001u;
}
void GUIResInfo::clear_has_gui_controls() {
  _has_bits_[0] &= ~0x00000001u;
}
void GUIResInfo::clear_gui_controls() {
  gui_controls_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_gui_controls();
}
 const ::std::string& GUIResInfo::gui_controls() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.GUIResInfo.gui_controls)
  return gui_controls_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GUIResInfo::set_gui_controls(const ::std::string& value) {
  set_has_gui_controls();
  gui_controls_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NetworkPacket.GUIResInfo.gui_controls)
}
 void GUIResInfo::set_gui_controls(const char* value) {
  set_has_gui_controls();
  gui_controls_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NetworkPacket.GUIResInfo.gui_controls)
}
 void GUIResInfo::set_gui_controls(const char* value, size_t size) {
  set_has_gui_controls();
  gui_controls_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NetworkPacket.GUIResInfo.gui_controls)
}
 ::std::string* GUIResInfo::mutable_gui_controls() {
  set_has_gui_controls();
  // @@protoc_insertion_point(field_mutable:NetworkPacket.GUIResInfo.gui_controls)
  return gui_controls_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* GUIResInfo::release_gui_controls() {
  // @@protoc_insertion_point(field_release:NetworkPacket.GUIResInfo.gui_controls)
  clear_has_gui_controls();
  return gui_controls_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GUIResInfo::set_allocated_gui_controls(::std::string* gui_controls) {
  if (gui_controls != NULL) {
    set_has_gui_controls();
  } else {
    clear_has_gui_controls();
  }
  gui_controls_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), gui_controls);
  // @@protoc_insertion_point(field_set_allocated:NetworkPacket.GUIResInfo.gui_controls)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForPerformanceInfo(
    PerformanceInfo* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int PerformanceInfo::kUidFieldNumber;
const int PerformanceInfo::kFileOpenCountFieldNumber;
const int PerformanceInfo::kFileReadCountFieldNumber;
const int PerformanceInfo::kFileReadBytesFieldNumber;
const int PerformanceInfo::kFileWriteCountFieldNumber;
const int PerformanceInfo::kFileWriteBytesFieldNumber;
const int PerformanceInfo::kGlApiCountFieldNumber;
const int PerformanceInfo::kGlDpCountFieldNumber;
const int PerformanceInfo::kGlCompressedTexCountFieldNumber;
const int PerformanceInfo::kGlTexCountFieldNumber;
const int PerformanceInfo::kGlTexBytesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

PerformanceInfo::PerformanceInfo()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:NetworkPacket.PerformanceInfo)
}

void PerformanceInfo::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  uid_ = const_cast< ::NetworkPacket::UID*>(
      ::NetworkPacket::UID::internal_default_instance());
#else
  uid_ = const_cast< ::NetworkPacket::UID*>(&::NetworkPacket::UID::default_instance());
#endif
}

PerformanceInfo::PerformanceInfo(const PerformanceInfo& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:NetworkPacket.PerformanceInfo)
}

void PerformanceInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  uid_ = NULL;
  file_open_count_ = GOOGLE_ULONGLONG(0);
  file_read_count_ = GOOGLE_ULONGLONG(0);
  file_read_bytes_ = GOOGLE_ULONGLONG(0);
  file_write_count_ = GOOGLE_ULONGLONG(0);
  file_write_bytes_ = GOOGLE_ULONGLONG(0);
  gl_api_count_ = GOOGLE_ULONGLONG(0);
  gl_dp_count_ = GOOGLE_ULONGLONG(0);
  gl_compressed_tex_count_ = GOOGLE_ULONGLONG(0);
  gl_tex_count_ = GOOGLE_ULONGLONG(0);
  gl_tex_bytes_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PerformanceInfo::~PerformanceInfo() {
  // @@protoc_insertion_point(destructor:NetworkPacket.PerformanceInfo)
  SharedDtor();
}

void PerformanceInfo::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete uid_;
  }
}

void PerformanceInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PerformanceInfo& PerformanceInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_NetworkPacket_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_NetworkPacket_2eproto();
#endif
  return *default_instance_;
}

PerformanceInfo* PerformanceInfo::default_instance_ = NULL;

PerformanceInfo* PerformanceInfo::New(::google::protobuf::Arena* arena) const {
  PerformanceInfo* n = new PerformanceInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void PerformanceInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:NetworkPacket.PerformanceInfo)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(PerformanceInfo, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<PerformanceInfo*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 255u) {
    ZR_(file_open_count_, gl_dp_count_);
    if (has_uid()) {
      if (uid_ != NULL) uid_->::NetworkPacket::UID::Clear();
    }
  }
  ZR_(gl_compressed_tex_count_, gl_tex_bytes_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool PerformanceInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForPerformanceInfo, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:NetworkPacket.PerformanceInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .NetworkPacket.UID uid = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_uid()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_file_open_count;
        break;
      }

      // required uint64 file_open_count = 2;
      case 2: {
        if (tag == 16) {
         parse_file_open_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &file_open_count_)));
          set_has_file_open_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_file_read_count;
        break;
      }

      // required uint64 file_read_count = 3;
      case 3: {
        if (tag == 24) {
         parse_file_read_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &file_read_count_)));
          set_has_file_read_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_file_read_bytes;
        break;
      }

      // required uint64 file_read_bytes = 4;
      case 4: {
        if (tag == 32) {
         parse_file_read_bytes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &file_read_bytes_)));
          set_has_file_read_bytes();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_file_write_count;
        break;
      }

      // required uint64 file_write_count = 5;
      case 5: {
        if (tag == 40) {
         parse_file_write_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &file_write_count_)));
          set_has_file_write_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_file_write_bytes;
        break;
      }

      // required uint64 file_write_bytes = 6;
      case 6: {
        if (tag == 48) {
         parse_file_write_bytes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &file_write_bytes_)));
          set_has_file_write_bytes();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_gl_api_count;
        break;
      }

      // required uint64 gl_api_count = 7;
      case 7: {
        if (tag == 56) {
         parse_gl_api_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &gl_api_count_)));
          set_has_gl_api_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_gl_dp_count;
        break;
      }

      // required uint64 gl_dp_count = 8;
      case 8: {
        if (tag == 64) {
         parse_gl_dp_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &gl_dp_count_)));
          set_has_gl_dp_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_gl_compressed_tex_count;
        break;
      }

      // required uint64 gl_compressed_tex_count = 9;
      case 9: {
        if (tag == 72) {
         parse_gl_compressed_tex_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &gl_compressed_tex_count_)));
          set_has_gl_compressed_tex_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_gl_tex_count;
        break;
      }

      // required uint64 gl_tex_count = 10;
      case 10: {
        if (tag == 80) {
         parse_gl_tex_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &gl_tex_count_)));
          set_has_gl_tex_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(88)) goto parse_gl_tex_bytes;
        break;
      }

      // required uint64 gl_tex_bytes = 11;
      case 11: {
        if (tag == 88) {
         parse_gl_tex_bytes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &gl_tex_bytes_)));
          set_has_gl_tex_bytes();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:NetworkPacket.PerformanceInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:NetworkPacket.PerformanceInfo)
  return false;
#undef DO_
}

void PerformanceInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:NetworkPacket.PerformanceInfo)
  // required .NetworkPacket.UID uid = 1;
  if (has_uid()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->uid_, output);
  }

  // required uint64 file_open_count = 2;
  if (has_file_open_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->file_open_count(), output);
  }

  // required uint64 file_read_count = 3;
  if (has_file_read_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->file_read_count(), output);
  }

  // required uint64 file_read_bytes = 4;
  if (has_file_read_bytes()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->file_read_bytes(), output);
  }

  // required uint64 file_write_count = 5;
  if (has_file_write_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(5, this->file_write_count(), output);
  }

  // required uint64 file_write_bytes = 6;
  if (has_file_write_bytes()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(6, this->file_write_bytes(), output);
  }

  // required uint64 gl_api_count = 7;
  if (has_gl_api_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(7, this->gl_api_count(), output);
  }

  // required uint64 gl_dp_count = 8;
  if (has_gl_dp_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(8, this->gl_dp_count(), output);
  }

  // required uint64 gl_compressed_tex_count = 9;
  if (has_gl_compressed_tex_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(9, this->gl_compressed_tex_count(), output);
  }

  // required uint64 gl_tex_count = 10;
  if (has_gl_tex_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(10, this->gl_tex_count(), output);
  }

  // required uint64 gl_tex_bytes = 11;
  if (has_gl_tex_bytes()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(11, this->gl_tex_bytes(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:NetworkPacket.PerformanceInfo)
}

int PerformanceInfo::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:NetworkPacket.PerformanceInfo)
  int total_size = 0;

  if (has_uid()) {
    // required .NetworkPacket.UID uid = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->uid_);
  }

  if (has_file_open_count()) {
    // required uint64 file_open_count = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->file_open_count());
  }

  if (has_file_read_count()) {
    // required uint64 file_read_count = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->file_read_count());
  }

  if (has_file_read_bytes()) {
    // required uint64 file_read_bytes = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->file_read_bytes());
  }

  if (has_file_write_count()) {
    // required uint64 file_write_count = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->file_write_count());
  }

  if (has_file_write_bytes()) {
    // required uint64 file_write_bytes = 6;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->file_write_bytes());
  }

  if (has_gl_api_count()) {
    // required uint64 gl_api_count = 7;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->gl_api_count());
  }

  if (has_gl_dp_count()) {
    // required uint64 gl_dp_count = 8;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->gl_dp_count());
  }

  if (has_gl_compressed_tex_count()) {
    // required uint64 gl_compressed_tex_count = 9;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->gl_compressed_tex_count());
  }

  if (has_gl_tex_count()) {
    // required uint64 gl_tex_count = 10;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->gl_tex_count());
  }

  if (has_gl_tex_bytes()) {
    // required uint64 gl_tex_bytes = 11;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->gl_tex_bytes());
  }

  return total_size;
}
int PerformanceInfo::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:NetworkPacket.PerformanceInfo)
  int total_size = 0;

  if (((_has_bits_[0] & 0x000007ff) ^ 0x000007ff) == 0) {  // All required fields are present.
    // required .NetworkPacket.UID uid = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->uid_);

    // required uint64 file_open_count = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->file_open_count());

    // required uint64 file_read_count = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->file_read_count());

    // required uint64 file_read_bytes = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->file_read_bytes());

    // required uint64 file_write_count = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->file_write_count());

    // required uint64 file_write_bytes = 6;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->file_write_bytes());

    // required uint64 gl_api_count = 7;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->gl_api_count());

    // required uint64 gl_dp_count = 8;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->gl_dp_count());

    // required uint64 gl_compressed_tex_count = 9;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->gl_compressed_tex_count());

    // required uint64 gl_tex_count = 10;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->gl_tex_count());

    // required uint64 gl_tex_bytes = 11;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->gl_tex_bytes());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PerformanceInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PerformanceInfo*>(&from));
}

void PerformanceInfo::MergeFrom(const PerformanceInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:NetworkPacket.PerformanceInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uid()) {
      mutable_uid()->::NetworkPacket::UID::MergeFrom(from.uid());
    }
    if (from.has_file_open_count()) {
      set_file_open_count(from.file_open_count());
    }
    if (from.has_file_read_count()) {
      set_file_read_count(from.file_read_count());
    }
    if (from.has_file_read_bytes()) {
      set_file_read_bytes(from.file_read_bytes());
    }
    if (from.has_file_write_count()) {
      set_file_write_count(from.file_write_count());
    }
    if (from.has_file_write_bytes()) {
      set_file_write_bytes(from.file_write_bytes());
    }
    if (from.has_gl_api_count()) {
      set_gl_api_count(from.gl_api_count());
    }
    if (from.has_gl_dp_count()) {
      set_gl_dp_count(from.gl_dp_count());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_gl_compressed_tex_count()) {
      set_gl_compressed_tex_count(from.gl_compressed_tex_count());
    }
    if (from.has_gl_tex_count()) {
      set_gl_tex_count(from.gl_tex_count());
    }
    if (from.has_gl_tex_bytes()) {
      set_gl_tex_bytes(from.gl_tex_bytes());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void PerformanceInfo::CopyFrom(const PerformanceInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NetworkPacket.PerformanceInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PerformanceInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x000007ff) != 0x000007ff) return false;

  if (has_uid()) {
    if (!this->uid_->IsInitialized()) return false;
  }
  return true;
}

void PerformanceInfo::Swap(PerformanceInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PerformanceInfo::InternalSwap(PerformanceInfo* other) {
  std::swap(uid_, other->uid_);
  std::swap(file_open_count_, other->file_open_count_);
  std::swap(file_read_count_, other->file_read_count_);
  std::swap(file_read_bytes_, other->file_read_bytes_);
  std::swap(file_write_count_, other->file_write_count_);
  std::swap(file_write_bytes_, other->file_write_bytes_);
  std::swap(gl_api_count_, other->gl_api_count_);
  std::swap(gl_dp_count_, other->gl_dp_count_);
  std::swap(gl_compressed_tex_count_, other->gl_compressed_tex_count_);
  std::swap(gl_tex_count_, other->gl_tex_count_);
  std::swap(gl_tex_bytes_, other->gl_tex_bytes_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string PerformanceInfo::GetTypeName() const {
  return "NetworkPacket.PerformanceInfo";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// PerformanceInfo

// required .NetworkPacket.UID uid = 1;
bool PerformanceInfo::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void PerformanceInfo::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
void PerformanceInfo::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
void PerformanceInfo::clear_uid() {
  if (uid_ != NULL) uid_->::NetworkPacket::UID::Clear();
  clear_has_uid();
}
const ::NetworkPacket::UID& PerformanceInfo::uid() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.PerformanceInfo.uid)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return uid_ != NULL ? *uid_ : *default_instance().uid_;
#else
  return uid_ != NULL ? *uid_ : *default_instance_->uid_;
#endif
}
::NetworkPacket::UID* PerformanceInfo::mutable_uid() {
  set_has_uid();
  if (uid_ == NULL) {
    uid_ = new ::NetworkPacket::UID;
  }
  // @@protoc_insertion_point(field_mutable:NetworkPacket.PerformanceInfo.uid)
  return uid_;
}
::NetworkPacket::UID* PerformanceInfo::release_uid() {
  // @@protoc_insertion_point(field_release:NetworkPacket.PerformanceInfo.uid)
  clear_has_uid();
  ::NetworkPacket::UID* temp = uid_;
  uid_ = NULL;
  return temp;
}
void PerformanceInfo::set_allocated_uid(::NetworkPacket::UID* uid) {
  delete uid_;
  uid_ = uid;
  if (uid) {
    set_has_uid();
  } else {
    clear_has_uid();
  }
  // @@protoc_insertion_point(field_set_allocated:NetworkPacket.PerformanceInfo.uid)
}

// required uint64 file_open_count = 2;
bool PerformanceInfo::has_file_open_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void PerformanceInfo::set_has_file_open_count() {
  _has_bits_[0] |= 0x00000002u;
}
void PerformanceInfo::clear_has_file_open_count() {
  _has_bits_[0] &= ~0x00000002u;
}
void PerformanceInfo::clear_file_open_count() {
  file_open_count_ = GOOGLE_ULONGLONG(0);
  clear_has_file_open_count();
}
 ::google::protobuf::uint64 PerformanceInfo::file_open_count() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.PerformanceInfo.file_open_count)
  return file_open_count_;
}
 void PerformanceInfo::set_file_open_count(::google::protobuf::uint64 value) {
  set_has_file_open_count();
  file_open_count_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.PerformanceInfo.file_open_count)
}

// required uint64 file_read_count = 3;
bool PerformanceInfo::has_file_read_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void PerformanceInfo::set_has_file_read_count() {
  _has_bits_[0] |= 0x00000004u;
}
void PerformanceInfo::clear_has_file_read_count() {
  _has_bits_[0] &= ~0x00000004u;
}
void PerformanceInfo::clear_file_read_count() {
  file_read_count_ = GOOGLE_ULONGLONG(0);
  clear_has_file_read_count();
}
 ::google::protobuf::uint64 PerformanceInfo::file_read_count() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.PerformanceInfo.file_read_count)
  return file_read_count_;
}
 void PerformanceInfo::set_file_read_count(::google::protobuf::uint64 value) {
  set_has_file_read_count();
  file_read_count_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.PerformanceInfo.file_read_count)
}

// required uint64 file_read_bytes = 4;
bool PerformanceInfo::has_file_read_bytes() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void PerformanceInfo::set_has_file_read_bytes() {
  _has_bits_[0] |= 0x00000008u;
}
void PerformanceInfo::clear_has_file_read_bytes() {
  _has_bits_[0] &= ~0x00000008u;
}
void PerformanceInfo::clear_file_read_bytes() {
  file_read_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_file_read_bytes();
}
 ::google::protobuf::uint64 PerformanceInfo::file_read_bytes() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.PerformanceInfo.file_read_bytes)
  return file_read_bytes_;
}
 void PerformanceInfo::set_file_read_bytes(::google::protobuf::uint64 value) {
  set_has_file_read_bytes();
  file_read_bytes_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.PerformanceInfo.file_read_bytes)
}

// required uint64 file_write_count = 5;
bool PerformanceInfo::has_file_write_count() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void PerformanceInfo::set_has_file_write_count() {
  _has_bits_[0] |= 0x00000010u;
}
void PerformanceInfo::clear_has_file_write_count() {
  _has_bits_[0] &= ~0x00000010u;
}
void PerformanceInfo::clear_file_write_count() {
  file_write_count_ = GOOGLE_ULONGLONG(0);
  clear_has_file_write_count();
}
 ::google::protobuf::uint64 PerformanceInfo::file_write_count() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.PerformanceInfo.file_write_count)
  return file_write_count_;
}
 void PerformanceInfo::set_file_write_count(::google::protobuf::uint64 value) {
  set_has_file_write_count();
  file_write_count_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.PerformanceInfo.file_write_count)
}

// required uint64 file_write_bytes = 6;
bool PerformanceInfo::has_file_write_bytes() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void PerformanceInfo::set_has_file_write_bytes() {
  _has_bits_[0] |= 0x00000020u;
}
void PerformanceInfo::clear_has_file_write_bytes() {
  _has_bits_[0] &= ~0x00000020u;
}
void PerformanceInfo::clear_file_write_bytes() {
  file_write_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_file_write_bytes();
}
 ::google::protobuf::uint64 PerformanceInfo::file_write_bytes() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.PerformanceInfo.file_write_bytes)
  return file_write_bytes_;
}
 void PerformanceInfo::set_file_write_bytes(::google::protobuf::uint64 value) {
  set_has_file_write_bytes();
  file_write_bytes_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.PerformanceInfo.file_write_bytes)
}

// required uint64 gl_api_count = 7;
bool PerformanceInfo::has_gl_api_count() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void PerformanceInfo::set_has_gl_api_count() {
  _has_bits_[0] |= 0x00000040u;
}
void PerformanceInfo::clear_has_gl_api_count() {
  _has_bits_[0] &= ~0x00000040u;
}
void PerformanceInfo::clear_gl_api_count() {
  gl_api_count_ = GOOGLE_ULONGLONG(0);
  clear_has_gl_api_count();
}
 ::google::protobuf::uint64 PerformanceInfo::gl_api_count() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.PerformanceInfo.gl_api_count)
  return gl_api_count_;
}
 void PerformanceInfo::set_gl_api_count(::google::protobuf::uint64 value) {
  set_has_gl_api_count();
  gl_api_count_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.PerformanceInfo.gl_api_count)
}

// required uint64 gl_dp_count = 8;
bool PerformanceInfo::has_gl_dp_count() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void PerformanceInfo::set_has_gl_dp_count() {
  _has_bits_[0] |= 0x00000080u;
}
void PerformanceInfo::clear_has_gl_dp_count() {
  _has_bits_[0] &= ~0x00000080u;
}
void PerformanceInfo::clear_gl_dp_count() {
  gl_dp_count_ = GOOGLE_ULONGLONG(0);
  clear_has_gl_dp_count();
}
 ::google::protobuf::uint64 PerformanceInfo::gl_dp_count() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.PerformanceInfo.gl_dp_count)
  return gl_dp_count_;
}
 void PerformanceInfo::set_gl_dp_count(::google::protobuf::uint64 value) {
  set_has_gl_dp_count();
  gl_dp_count_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.PerformanceInfo.gl_dp_count)
}

// required uint64 gl_compressed_tex_count = 9;
bool PerformanceInfo::has_gl_compressed_tex_count() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void PerformanceInfo::set_has_gl_compressed_tex_count() {
  _has_bits_[0] |= 0x00000100u;
}
void PerformanceInfo::clear_has_gl_compressed_tex_count() {
  _has_bits_[0] &= ~0x00000100u;
}
void PerformanceInfo::clear_gl_compressed_tex_count() {
  gl_compressed_tex_count_ = GOOGLE_ULONGLONG(0);
  clear_has_gl_compressed_tex_count();
}
 ::google::protobuf::uint64 PerformanceInfo::gl_compressed_tex_count() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.PerformanceInfo.gl_compressed_tex_count)
  return gl_compressed_tex_count_;
}
 void PerformanceInfo::set_gl_compressed_tex_count(::google::protobuf::uint64 value) {
  set_has_gl_compressed_tex_count();
  gl_compressed_tex_count_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.PerformanceInfo.gl_compressed_tex_count)
}

// required uint64 gl_tex_count = 10;
bool PerformanceInfo::has_gl_tex_count() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
void PerformanceInfo::set_has_gl_tex_count() {
  _has_bits_[0] |= 0x00000200u;
}
void PerformanceInfo::clear_has_gl_tex_count() {
  _has_bits_[0] &= ~0x00000200u;
}
void PerformanceInfo::clear_gl_tex_count() {
  gl_tex_count_ = GOOGLE_ULONGLONG(0);
  clear_has_gl_tex_count();
}
 ::google::protobuf::uint64 PerformanceInfo::gl_tex_count() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.PerformanceInfo.gl_tex_count)
  return gl_tex_count_;
}
 void PerformanceInfo::set_gl_tex_count(::google::protobuf::uint64 value) {
  set_has_gl_tex_count();
  gl_tex_count_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.PerformanceInfo.gl_tex_count)
}

// required uint64 gl_tex_bytes = 11;
bool PerformanceInfo::has_gl_tex_bytes() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
void PerformanceInfo::set_has_gl_tex_bytes() {
  _has_bits_[0] |= 0x00000400u;
}
void PerformanceInfo::clear_has_gl_tex_bytes() {
  _has_bits_[0] &= ~0x00000400u;
}
void PerformanceInfo::clear_gl_tex_bytes() {
  gl_tex_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_gl_tex_bytes();
}
 ::google::protobuf::uint64 PerformanceInfo::gl_tex_bytes() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.PerformanceInfo.gl_tex_bytes)
  return gl_tex_bytes_;
}
 void PerformanceInfo::set_gl_tex_bytes(::google::protobuf::uint64 value) {
  set_has_gl_tex_bytes();
  gl_tex_bytes_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.PerformanceInfo.gl_tex_bytes)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForPerformanceParticlesInfo(
    PerformanceParticlesInfo* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int PerformanceParticlesInfo::kEnableFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

PerformanceParticlesInfo::PerformanceParticlesInfo()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:NetworkPacket.PerformanceParticlesInfo)
}

void PerformanceParticlesInfo::InitAsDefaultInstance() {
}

PerformanceParticlesInfo::PerformanceParticlesInfo(const PerformanceParticlesInfo& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:NetworkPacket.PerformanceParticlesInfo)
}

void PerformanceParticlesInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  enable_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PerformanceParticlesInfo::~PerformanceParticlesInfo() {
  // @@protoc_insertion_point(destructor:NetworkPacket.PerformanceParticlesInfo)
  SharedDtor();
}

void PerformanceParticlesInfo::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PerformanceParticlesInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PerformanceParticlesInfo& PerformanceParticlesInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_NetworkPacket_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_NetworkPacket_2eproto();
#endif
  return *default_instance_;
}

PerformanceParticlesInfo* PerformanceParticlesInfo::default_instance_ = NULL;

PerformanceParticlesInfo* PerformanceParticlesInfo::New(::google::protobuf::Arena* arena) const {
  PerformanceParticlesInfo* n = new PerformanceParticlesInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void PerformanceParticlesInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:NetworkPacket.PerformanceParticlesInfo)
  enable_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool PerformanceParticlesInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForPerformanceParticlesInfo, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:NetworkPacket.PerformanceParticlesInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool enable = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &enable_)));
          set_has_enable();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:NetworkPacket.PerformanceParticlesInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:NetworkPacket.PerformanceParticlesInfo)
  return false;
#undef DO_
}

void PerformanceParticlesInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:NetworkPacket.PerformanceParticlesInfo)
  // required bool enable = 1;
  if (has_enable()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->enable(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:NetworkPacket.PerformanceParticlesInfo)
}

int PerformanceParticlesInfo::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:NetworkPacket.PerformanceParticlesInfo)
  int total_size = 0;

  // required bool enable = 1;
  if (has_enable()) {
    total_size += 1 + 1;
  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PerformanceParticlesInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PerformanceParticlesInfo*>(&from));
}

void PerformanceParticlesInfo::MergeFrom(const PerformanceParticlesInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:NetworkPacket.PerformanceParticlesInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_enable()) {
      set_enable(from.enable());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void PerformanceParticlesInfo::CopyFrom(const PerformanceParticlesInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NetworkPacket.PerformanceParticlesInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PerformanceParticlesInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void PerformanceParticlesInfo::Swap(PerformanceParticlesInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PerformanceParticlesInfo::InternalSwap(PerformanceParticlesInfo* other) {
  std::swap(enable_, other->enable_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string PerformanceParticlesInfo::GetTypeName() const {
  return "NetworkPacket.PerformanceParticlesInfo";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// PerformanceParticlesInfo

// required bool enable = 1;
bool PerformanceParticlesInfo::has_enable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void PerformanceParticlesInfo::set_has_enable() {
  _has_bits_[0] |= 0x00000001u;
}
void PerformanceParticlesInfo::clear_has_enable() {
  _has_bits_[0] &= ~0x00000001u;
}
void PerformanceParticlesInfo::clear_enable() {
  enable_ = false;
  clear_has_enable();
}
 bool PerformanceParticlesInfo::enable() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.PerformanceParticlesInfo.enable)
  return enable_;
}
 void PerformanceParticlesInfo::set_enable(bool value) {
  set_has_enable();
  enable_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.PerformanceParticlesInfo.enable)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForPerformanceGlobalShaderInfo(
    PerformanceGlobalShaderInfo* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int PerformanceGlobalShaderInfo::kNameFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

PerformanceGlobalShaderInfo::PerformanceGlobalShaderInfo()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:NetworkPacket.PerformanceGlobalShaderInfo)
}

void PerformanceGlobalShaderInfo::InitAsDefaultInstance() {
}

PerformanceGlobalShaderInfo::PerformanceGlobalShaderInfo(const PerformanceGlobalShaderInfo& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:NetworkPacket.PerformanceGlobalShaderInfo)
}

void PerformanceGlobalShaderInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PerformanceGlobalShaderInfo::~PerformanceGlobalShaderInfo() {
  // @@protoc_insertion_point(destructor:NetworkPacket.PerformanceGlobalShaderInfo)
  SharedDtor();
}

void PerformanceGlobalShaderInfo::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PerformanceGlobalShaderInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PerformanceGlobalShaderInfo& PerformanceGlobalShaderInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_NetworkPacket_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_NetworkPacket_2eproto();
#endif
  return *default_instance_;
}

PerformanceGlobalShaderInfo* PerformanceGlobalShaderInfo::default_instance_ = NULL;

PerformanceGlobalShaderInfo* PerformanceGlobalShaderInfo::New(::google::protobuf::Arena* arena) const {
  PerformanceGlobalShaderInfo* n = new PerformanceGlobalShaderInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void PerformanceGlobalShaderInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:NetworkPacket.PerformanceGlobalShaderInfo)
  if (has_name()) {
    name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool PerformanceGlobalShaderInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForPerformanceGlobalShaderInfo, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:NetworkPacket.PerformanceGlobalShaderInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:NetworkPacket.PerformanceGlobalShaderInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:NetworkPacket.PerformanceGlobalShaderInfo)
  return false;
#undef DO_
}

void PerformanceGlobalShaderInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:NetworkPacket.PerformanceGlobalShaderInfo)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:NetworkPacket.PerformanceGlobalShaderInfo)
}

int PerformanceGlobalShaderInfo::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:NetworkPacket.PerformanceGlobalShaderInfo)
  int total_size = 0;

  // required string name = 1;
  if (has_name()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->name());
  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PerformanceGlobalShaderInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PerformanceGlobalShaderInfo*>(&from));
}

void PerformanceGlobalShaderInfo::MergeFrom(const PerformanceGlobalShaderInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:NetworkPacket.PerformanceGlobalShaderInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_has_name();
      name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void PerformanceGlobalShaderInfo::CopyFrom(const PerformanceGlobalShaderInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NetworkPacket.PerformanceGlobalShaderInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PerformanceGlobalShaderInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void PerformanceGlobalShaderInfo::Swap(PerformanceGlobalShaderInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PerformanceGlobalShaderInfo::InternalSwap(PerformanceGlobalShaderInfo* other) {
  name_.Swap(&other->name_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string PerformanceGlobalShaderInfo::GetTypeName() const {
  return "NetworkPacket.PerformanceGlobalShaderInfo";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// PerformanceGlobalShaderInfo

// required string name = 1;
bool PerformanceGlobalShaderInfo::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void PerformanceGlobalShaderInfo::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
void PerformanceGlobalShaderInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void PerformanceGlobalShaderInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
 const ::std::string& PerformanceGlobalShaderInfo::name() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.PerformanceGlobalShaderInfo.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void PerformanceGlobalShaderInfo::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NetworkPacket.PerformanceGlobalShaderInfo.name)
}
 void PerformanceGlobalShaderInfo::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NetworkPacket.PerformanceGlobalShaderInfo.name)
}
 void PerformanceGlobalShaderInfo::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NetworkPacket.PerformanceGlobalShaderInfo.name)
}
 ::std::string* PerformanceGlobalShaderInfo::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:NetworkPacket.PerformanceGlobalShaderInfo.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* PerformanceGlobalShaderInfo::release_name() {
  // @@protoc_insertion_point(field_release:NetworkPacket.PerformanceGlobalShaderInfo.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void PerformanceGlobalShaderInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:NetworkPacket.PerformanceGlobalShaderInfo.name)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace NetworkPacket

// @@protoc_insertion_point(global_scope)
