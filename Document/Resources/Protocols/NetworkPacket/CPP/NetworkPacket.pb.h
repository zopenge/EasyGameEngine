// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: NetworkPacket.proto

#ifndef PROTOBUF_NetworkPacket_2eproto__INCLUDED
#define PROTOBUF_NetworkPacket_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)

namespace NetworkPacket {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_NetworkPacket_2eproto();
void protobuf_AssignDesc_NetworkPacket_2eproto();
void protobuf_ShutdownFile_NetworkPacket_2eproto();

class DeviceInfo;
class DeviceMemResInfo;
class DeviceMemResources;
class DeviceRunTimeInfo;
class DeviceShaderResources;
class DeviceTexResources;
class GUIResInfo;
class KeepAliveInfo;
class LogStringInfo;
class LoginInfo;
class LogoutInfo;
class PerformanceGlobalShaderInfo;
class PerformanceInfo;
class PerformanceParticlesInfo;
class ShaderResInfo;
class TextureChangeSamplerFilter;
class TextureResInfo;
class ThreadInfo;
class ThreadsInfo;
class UID;

enum Constant {
  KEEP_ALIVE_CHECK_INTERVAL = 60000
};
bool Constant_IsValid(int value);
const Constant Constant_MIN = KEEP_ALIVE_CHECK_INTERVAL;
const Constant Constant_MAX = KEEP_ALIVE_CHECK_INTERVAL;
const int Constant_ARRAYSIZE = Constant_MAX + 1;

enum MessageType {
  MT_KEEP_ALIVE = 1,
  MT_LOGIN = 2,
  MT_LOGOUT = 3,
  MT_RUNTIME_INFO = 100,
  MT_RUNTIME_THREADS_INFO = 101,
  MT_LOGGER_STRING = 200,
  MT_LOGGER_STRING_IN_ZLIB = 201,
  MT_DEVICE_TEXTURE_RESOURCES = 300,
  MT_DEVICE_TEXTURE_CHANGE_SAMPLER_FILTER = 301,
  MT_DEVICE_SHADER_RESOURCES = 310,
  MT_DEVICE_SHADER_UPDATE = 311,
  MT_DEVICE_MEM_RESOURCES = 400,
  MT_DEVICE_GUI_RESOURCES = 500,
  MT_DEVICE_PERFORMANCE = 600,
  MT_DEVICE_PERFORMANCE_PARTICLES = 601,
  MT_DEVICE_PERFORMANCE_GLOBAL_SHADER = 602
};
bool MessageType_IsValid(int value);
const MessageType MessageType_MIN = MT_KEEP_ALIVE;
const MessageType MessageType_MAX = MT_DEVICE_PERFORMANCE_GLOBAL_SHADER;
const int MessageType_ARRAYSIZE = MessageType_MAX + 1;

enum TextureType {
  TT_TEX2D = 1,
  TT_TEXCUBEMAP = 2
};
bool TextureType_IsValid(int value);
const TextureType TextureType_MIN = TT_TEX2D;
const TextureType TextureType_MAX = TT_TEXCUBEMAP;
const int TextureType_ARRAYSIZE = TextureType_MAX + 1;

enum SamplerType {
  _SF_UNKNOWN = 1,
  _SF_NEAREST = 2,
  _SF_LINEAR = 3
};
bool SamplerType_IsValid(int value);
const SamplerType SamplerType_MIN = _SF_UNKNOWN;
const SamplerType SamplerType_MAX = _SF_LINEAR;
const int SamplerType_ARRAYSIZE = SamplerType_MAX + 1;

// ===================================================================

class KeepAliveInfo : public ::google::protobuf::MessageLite {
 public:
  KeepAliveInfo();
  virtual ~KeepAliveInfo();

  KeepAliveInfo(const KeepAliveInfo& from);

  inline KeepAliveInfo& operator=(const KeepAliveInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const KeepAliveInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const KeepAliveInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(KeepAliveInfo* other);

  // implements Message ----------------------------------------------

  inline KeepAliveInfo* New() const { return New(NULL); }

  KeepAliveInfo* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const KeepAliveInfo& from);
  void MergeFrom(const KeepAliveInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(KeepAliveInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 number = 1;
  bool has_number() const;
  void clear_number();
  static const int kNumberFieldNumber = 1;
  ::google::protobuf::uint32 number() const;
  void set_number(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:NetworkPacket.KeepAliveInfo)
 private:
  inline void set_has_number();
  inline void clear_has_number();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 number_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_NetworkPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_NetworkPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_NetworkPacket_2eproto();
  friend void protobuf_ShutdownFile_NetworkPacket_2eproto();

  void InitAsDefaultInstance();
  static KeepAliveInfo* default_instance_;
};
// -------------------------------------------------------------------

class UID : public ::google::protobuf::MessageLite {
 public:
  UID();
  virtual ~UID();

  UID(const UID& from);

  inline UID& operator=(const UID& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const UID& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UID* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UID* other);

  // implements Message ----------------------------------------------

  inline UID* New() const { return New(NULL); }

  UID* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UID& from);
  void MergeFrom(const UID& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UID* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 data1 = 1;
  bool has_data1() const;
  void clear_data1();
  static const int kData1FieldNumber = 1;
  ::google::protobuf::uint32 data1() const;
  void set_data1(::google::protobuf::uint32 value);

  // required uint32 data2 = 2;
  bool has_data2() const;
  void clear_data2();
  static const int kData2FieldNumber = 2;
  ::google::protobuf::uint32 data2() const;
  void set_data2(::google::protobuf::uint32 value);

  // required uint32 data3 = 3;
  bool has_data3() const;
  void clear_data3();
  static const int kData3FieldNumber = 3;
  ::google::protobuf::uint32 data3() const;
  void set_data3(::google::protobuf::uint32 value);

  // required uint32 data4 = 4;
  bool has_data4() const;
  void clear_data4();
  static const int kData4FieldNumber = 4;
  ::google::protobuf::uint32 data4() const;
  void set_data4(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:NetworkPacket.UID)
 private:
  inline void set_has_data1();
  inline void clear_has_data1();
  inline void set_has_data2();
  inline void clear_has_data2();
  inline void set_has_data3();
  inline void clear_has_data3();
  inline void set_has_data4();
  inline void clear_has_data4();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 data1_;
  ::google::protobuf::uint32 data2_;
  ::google::protobuf::uint32 data3_;
  ::google::protobuf::uint32 data4_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_NetworkPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_NetworkPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_NetworkPacket_2eproto();
  friend void protobuf_ShutdownFile_NetworkPacket_2eproto();

  void InitAsDefaultInstance();
  static UID* default_instance_;
};
// -------------------------------------------------------------------

class DeviceInfo : public ::google::protobuf::MessageLite {
 public:
  DeviceInfo();
  virtual ~DeviceInfo();

  DeviceInfo(const DeviceInfo& from);

  inline DeviceInfo& operator=(const DeviceInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const DeviceInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DeviceInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DeviceInfo* other);

  // implements Message ----------------------------------------------

  inline DeviceInfo* New() const { return New(NULL); }

  DeviceInfo* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DeviceInfo& from);
  void MergeFrom(const DeviceInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .NetworkPacket.UID uid = 1;
  bool has_uid() const;
  void clear_uid();
  static const int kUidFieldNumber = 1;
  const ::NetworkPacket::UID& uid() const;
  ::NetworkPacket::UID* mutable_uid();
  ::NetworkPacket::UID* release_uid();
  void set_allocated_uid(::NetworkPacket::UID* uid);

  // required uint32 process_id = 2;
  bool has_process_id() const;
  void clear_process_id();
  static const int kProcessIdFieldNumber = 2;
  ::google::protobuf::uint32 process_id() const;
  void set_process_id(::google::protobuf::uint32 value);

  // required string brand_name = 3;
  bool has_brand_name() const;
  void clear_brand_name();
  static const int kBrandNameFieldNumber = 3;
  const ::std::string& brand_name() const;
  void set_brand_name(const ::std::string& value);
  void set_brand_name(const char* value);
  void set_brand_name(const char* value, size_t size);
  ::std::string* mutable_brand_name();
  ::std::string* release_brand_name();
  void set_allocated_brand_name(::std::string* brand_name);

  // required string device_name = 4;
  bool has_device_name() const;
  void clear_device_name();
  static const int kDeviceNameFieldNumber = 4;
  const ::std::string& device_name() const;
  void set_device_name(const ::std::string& value);
  void set_device_name(const char* value);
  void set_device_name(const char* value, size_t size);
  ::std::string* mutable_device_name();
  ::std::string* release_device_name();
  void set_allocated_device_name(::std::string* device_name);

  // required string cpu_name = 5;
  bool has_cpu_name() const;
  void clear_cpu_name();
  static const int kCpuNameFieldNumber = 5;
  const ::std::string& cpu_name() const;
  void set_cpu_name(const ::std::string& value);
  void set_cpu_name(const char* value);
  void set_cpu_name(const char* value, size_t size);
  ::std::string* mutable_cpu_name();
  ::std::string* release_cpu_name();
  void set_allocated_cpu_name(::std::string* cpu_name);

  // required uint32 cpu_core_number = 6;
  bool has_cpu_core_number() const;
  void clear_cpu_core_number();
  static const int kCpuCoreNumberFieldNumber = 6;
  ::google::protobuf::uint32 cpu_core_number() const;
  void set_cpu_core_number(::google::protobuf::uint32 value);

  // required string gpu_name = 7;
  bool has_gpu_name() const;
  void clear_gpu_name();
  static const int kGpuNameFieldNumber = 7;
  const ::std::string& gpu_name() const;
  void set_gpu_name(const ::std::string& value);
  void set_gpu_name(const char* value);
  void set_gpu_name(const char* value, size_t size);
  ::std::string* mutable_gpu_name();
  ::std::string* release_gpu_name();
  void set_allocated_gpu_name(::std::string* gpu_name);

  // required uint32 gpu_core_number = 8;
  bool has_gpu_core_number() const;
  void clear_gpu_core_number();
  static const int kGpuCoreNumberFieldNumber = 8;
  ::google::protobuf::uint32 gpu_core_number() const;
  void set_gpu_core_number(::google::protobuf::uint32 value);

  // required uint64 smem_size = 9;
  bool has_smem_size() const;
  void clear_smem_size();
  static const int kSmemSizeFieldNumber = 9;
  ::google::protobuf::uint64 smem_size() const;
  void set_smem_size(::google::protobuf::uint64 value);

  // required uint64 vmem_size = 10;
  bool has_vmem_size() const;
  void clear_vmem_size();
  static const int kVmemSizeFieldNumber = 10;
  ::google::protobuf::uint64 vmem_size() const;
  void set_vmem_size(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:NetworkPacket.DeviceInfo)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_process_id();
  inline void clear_has_process_id();
  inline void set_has_brand_name();
  inline void clear_has_brand_name();
  inline void set_has_device_name();
  inline void clear_has_device_name();
  inline void set_has_cpu_name();
  inline void clear_has_cpu_name();
  inline void set_has_cpu_core_number();
  inline void clear_has_cpu_core_number();
  inline void set_has_gpu_name();
  inline void clear_has_gpu_name();
  inline void set_has_gpu_core_number();
  inline void clear_has_gpu_core_number();
  inline void set_has_smem_size();
  inline void clear_has_smem_size();
  inline void set_has_vmem_size();
  inline void clear_has_vmem_size();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::NetworkPacket::UID* uid_;
  ::google::protobuf::internal::ArenaStringPtr brand_name_;
  ::google::protobuf::internal::ArenaStringPtr device_name_;
  ::google::protobuf::uint32 process_id_;
  ::google::protobuf::uint32 cpu_core_number_;
  ::google::protobuf::internal::ArenaStringPtr cpu_name_;
  ::google::protobuf::internal::ArenaStringPtr gpu_name_;
  ::google::protobuf::uint64 smem_size_;
  ::google::protobuf::uint64 vmem_size_;
  ::google::protobuf::uint32 gpu_core_number_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_NetworkPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_NetworkPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_NetworkPacket_2eproto();
  friend void protobuf_ShutdownFile_NetworkPacket_2eproto();

  void InitAsDefaultInstance();
  static DeviceInfo* default_instance_;
};
// -------------------------------------------------------------------

class DeviceRunTimeInfo : public ::google::protobuf::MessageLite {
 public:
  DeviceRunTimeInfo();
  virtual ~DeviceRunTimeInfo();

  DeviceRunTimeInfo(const DeviceRunTimeInfo& from);

  inline DeviceRunTimeInfo& operator=(const DeviceRunTimeInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const DeviceRunTimeInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DeviceRunTimeInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DeviceRunTimeInfo* other);

  // implements Message ----------------------------------------------

  inline DeviceRunTimeInfo* New() const { return New(NULL); }

  DeviceRunTimeInfo* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DeviceRunTimeInfo& from);
  void MergeFrom(const DeviceRunTimeInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceRunTimeInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .NetworkPacket.UID uid = 1;
  bool has_uid() const;
  void clear_uid();
  static const int kUidFieldNumber = 1;
  const ::NetworkPacket::UID& uid() const;
  ::NetworkPacket::UID* mutable_uid();
  ::NetworkPacket::UID* release_uid();
  void set_allocated_uid(::NetworkPacket::UID* uid);

  // required float fps = 2;
  bool has_fps() const;
  void clear_fps();
  static const int kFpsFieldNumber = 2;
  float fps() const;
  void set_fps(float value);

  // required uint64 smem_size = 3;
  bool has_smem_size() const;
  void clear_smem_size();
  static const int kSmemSizeFieldNumber = 3;
  ::google::protobuf::uint64 smem_size() const;
  void set_smem_size(::google::protobuf::uint64 value);

  // required uint64 vmem_size = 4;
  bool has_vmem_size() const;
  void clear_vmem_size();
  static const int kVmemSizeFieldNumber = 4;
  ::google::protobuf::uint64 vmem_size() const;
  void set_vmem_size(::google::protobuf::uint64 value);

  // required float cpu_usage = 5;
  bool has_cpu_usage() const;
  void clear_cpu_usage();
  static const int kCpuUsageFieldNumber = 5;
  float cpu_usage() const;
  void set_cpu_usage(float value);

  // required float gpu_usage = 6;
  bool has_gpu_usage() const;
  void clear_gpu_usage();
  static const int kGpuUsageFieldNumber = 6;
  float gpu_usage() const;
  void set_gpu_usage(float value);

  // @@protoc_insertion_point(class_scope:NetworkPacket.DeviceRunTimeInfo)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_fps();
  inline void clear_has_fps();
  inline void set_has_smem_size();
  inline void clear_has_smem_size();
  inline void set_has_vmem_size();
  inline void clear_has_vmem_size();
  inline void set_has_cpu_usage();
  inline void clear_has_cpu_usage();
  inline void set_has_gpu_usage();
  inline void clear_has_gpu_usage();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::NetworkPacket::UID* uid_;
  ::google::protobuf::uint64 smem_size_;
  float fps_;
  float cpu_usage_;
  ::google::protobuf::uint64 vmem_size_;
  float gpu_usage_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_NetworkPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_NetworkPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_NetworkPacket_2eproto();
  friend void protobuf_ShutdownFile_NetworkPacket_2eproto();

  void InitAsDefaultInstance();
  static DeviceRunTimeInfo* default_instance_;
};
// -------------------------------------------------------------------

class LoginInfo : public ::google::protobuf::MessageLite {
 public:
  LoginInfo();
  virtual ~LoginInfo();

  LoginInfo(const LoginInfo& from);

  inline LoginInfo& operator=(const LoginInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const LoginInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LoginInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LoginInfo* other);

  // implements Message ----------------------------------------------

  inline LoginInfo* New() const { return New(NULL); }

  LoginInfo* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LoginInfo& from);
  void MergeFrom(const LoginInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LoginInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .NetworkPacket.DeviceInfo device = 1;
  bool has_device() const;
  void clear_device();
  static const int kDeviceFieldNumber = 1;
  const ::NetworkPacket::DeviceInfo& device() const;
  ::NetworkPacket::DeviceInfo* mutable_device();
  ::NetworkPacket::DeviceInfo* release_device();
  void set_allocated_device(::NetworkPacket::DeviceInfo* device);

  // @@protoc_insertion_point(class_scope:NetworkPacket.LoginInfo)
 private:
  inline void set_has_device();
  inline void clear_has_device();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::NetworkPacket::DeviceInfo* device_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_NetworkPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_NetworkPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_NetworkPacket_2eproto();
  friend void protobuf_ShutdownFile_NetworkPacket_2eproto();

  void InitAsDefaultInstance();
  static LoginInfo* default_instance_;
};
// -------------------------------------------------------------------

class LogoutInfo : public ::google::protobuf::MessageLite {
 public:
  LogoutInfo();
  virtual ~LogoutInfo();

  LogoutInfo(const LogoutInfo& from);

  inline LogoutInfo& operator=(const LogoutInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const LogoutInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LogoutInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LogoutInfo* other);

  // implements Message ----------------------------------------------

  inline LogoutInfo* New() const { return New(NULL); }

  LogoutInfo* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LogoutInfo& from);
  void MergeFrom(const LogoutInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LogoutInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .NetworkPacket.DeviceInfo device = 1;
  bool has_device() const;
  void clear_device();
  static const int kDeviceFieldNumber = 1;
  const ::NetworkPacket::DeviceInfo& device() const;
  ::NetworkPacket::DeviceInfo* mutable_device();
  ::NetworkPacket::DeviceInfo* release_device();
  void set_allocated_device(::NetworkPacket::DeviceInfo* device);

  // @@protoc_insertion_point(class_scope:NetworkPacket.LogoutInfo)
 private:
  inline void set_has_device();
  inline void clear_has_device();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::NetworkPacket::DeviceInfo* device_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_NetworkPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_NetworkPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_NetworkPacket_2eproto();
  friend void protobuf_ShutdownFile_NetworkPacket_2eproto();

  void InitAsDefaultInstance();
  static LogoutInfo* default_instance_;
};
// -------------------------------------------------------------------

class ThreadInfo : public ::google::protobuf::MessageLite {
 public:
  ThreadInfo();
  virtual ~ThreadInfo();

  ThreadInfo(const ThreadInfo& from);

  inline ThreadInfo& operator=(const ThreadInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const ThreadInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ThreadInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ThreadInfo* other);

  // implements Message ----------------------------------------------

  inline ThreadInfo* New() const { return New(NULL); }

  ThreadInfo* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ThreadInfo& from);
  void MergeFrom(const ThreadInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ThreadInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint64 id() const;
  void set_id(::google::protobuf::uint64 value);

  // required string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required float cpu_usage = 3;
  bool has_cpu_usage() const;
  void clear_cpu_usage();
  static const int kCpuUsageFieldNumber = 3;
  float cpu_usage() const;
  void set_cpu_usage(float value);

  // @@protoc_insertion_point(class_scope:NetworkPacket.ThreadInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_cpu_usage();
  inline void clear_has_cpu_usage();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 id_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  float cpu_usage_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_NetworkPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_NetworkPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_NetworkPacket_2eproto();
  friend void protobuf_ShutdownFile_NetworkPacket_2eproto();

  void InitAsDefaultInstance();
  static ThreadInfo* default_instance_;
};
// -------------------------------------------------------------------

class ThreadsInfo : public ::google::protobuf::MessageLite {
 public:
  ThreadsInfo();
  virtual ~ThreadsInfo();

  ThreadsInfo(const ThreadsInfo& from);

  inline ThreadsInfo& operator=(const ThreadsInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const ThreadsInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ThreadsInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ThreadsInfo* other);

  // implements Message ----------------------------------------------

  inline ThreadsInfo* New() const { return New(NULL); }

  ThreadsInfo* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ThreadsInfo& from);
  void MergeFrom(const ThreadsInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ThreadsInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .NetworkPacket.UID uid = 1;
  bool has_uid() const;
  void clear_uid();
  static const int kUidFieldNumber = 1;
  const ::NetworkPacket::UID& uid() const;
  ::NetworkPacket::UID* mutable_uid();
  ::NetworkPacket::UID* release_uid();
  void set_allocated_uid(::NetworkPacket::UID* uid);

  // repeated .NetworkPacket.ThreadInfo threads = 2;
  int threads_size() const;
  void clear_threads();
  static const int kThreadsFieldNumber = 2;
  const ::NetworkPacket::ThreadInfo& threads(int index) const;
  ::NetworkPacket::ThreadInfo* mutable_threads(int index);
  ::NetworkPacket::ThreadInfo* add_threads();
  ::google::protobuf::RepeatedPtrField< ::NetworkPacket::ThreadInfo >*
      mutable_threads();
  const ::google::protobuf::RepeatedPtrField< ::NetworkPacket::ThreadInfo >&
      threads() const;

  // @@protoc_insertion_point(class_scope:NetworkPacket.ThreadsInfo)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::NetworkPacket::UID* uid_;
  ::google::protobuf::RepeatedPtrField< ::NetworkPacket::ThreadInfo > threads_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_NetworkPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_NetworkPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_NetworkPacket_2eproto();
  friend void protobuf_ShutdownFile_NetworkPacket_2eproto();

  void InitAsDefaultInstance();
  static ThreadsInfo* default_instance_;
};
// -------------------------------------------------------------------

class LogStringInfo : public ::google::protobuf::MessageLite {
 public:
  LogStringInfo();
  virtual ~LogStringInfo();

  LogStringInfo(const LogStringInfo& from);

  inline LogStringInfo& operator=(const LogStringInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const LogStringInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LogStringInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LogStringInfo* other);

  // implements Message ----------------------------------------------

  inline LogStringInfo* New() const { return New(NULL); }

  LogStringInfo* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LogStringInfo& from);
  void MergeFrom(const LogStringInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LogStringInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .NetworkPacket.UID uid = 1;
  bool has_uid() const;
  void clear_uid();
  static const int kUidFieldNumber = 1;
  const ::NetworkPacket::UID& uid() const;
  ::NetworkPacket::UID* mutable_uid();
  ::NetworkPacket::UID* release_uid();
  void set_allocated_uid(::NetworkPacket::UID* uid);

  // required bool has_compressed = 2;
  bool has_has_compressed() const;
  void clear_has_compressed();
  static const int kHasCompressedFieldNumber = 2;
  bool has_compressed() const;
  void set_has_compressed(bool value);

  // required bytes log = 3;
  bool has_log() const;
  void clear_log();
  static const int kLogFieldNumber = 3;
  const ::std::string& log() const;
  void set_log(const ::std::string& value);
  void set_log(const char* value);
  void set_log(const void* value, size_t size);
  ::std::string* mutable_log();
  ::std::string* release_log();
  void set_allocated_log(::std::string* log);

  // @@protoc_insertion_point(class_scope:NetworkPacket.LogStringInfo)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_has_compressed();
  inline void clear_has_has_compressed();
  inline void set_has_log();
  inline void clear_has_log();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::NetworkPacket::UID* uid_;
  ::google::protobuf::internal::ArenaStringPtr log_;
  bool has_compressed_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_NetworkPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_NetworkPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_NetworkPacket_2eproto();
  friend void protobuf_ShutdownFile_NetworkPacket_2eproto();

  void InitAsDefaultInstance();
  static LogStringInfo* default_instance_;
};
// -------------------------------------------------------------------

class TextureResInfo : public ::google::protobuf::MessageLite {
 public:
  TextureResInfo();
  virtual ~TextureResInfo();

  TextureResInfo(const TextureResInfo& from);

  inline TextureResInfo& operator=(const TextureResInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const TextureResInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TextureResInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TextureResInfo* other);

  // implements Message ----------------------------------------------

  inline TextureResInfo* New() const { return New(NULL); }

  TextureResInfo* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TextureResInfo& from);
  void MergeFrom(const TextureResInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TextureResInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string res_name = 1;
  bool has_res_name() const;
  void clear_res_name();
  static const int kResNameFieldNumber = 1;
  const ::std::string& res_name() const;
  void set_res_name(const ::std::string& value);
  void set_res_name(const char* value);
  void set_res_name(const char* value, size_t size);
  ::std::string* mutable_res_name();
  ::std::string* release_res_name();
  void set_allocated_res_name(::std::string* res_name);

  // required .NetworkPacket.TextureType type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::NetworkPacket::TextureType type() const;
  void set_type(::NetworkPacket::TextureType value);

  // required uint32 res_id = 3;
  bool has_res_id() const;
  void clear_res_id();
  static const int kResIdFieldNumber = 3;
  ::google::protobuf::uint32 res_id() const;
  void set_res_id(::google::protobuf::uint32 value);

  // required uint32 width = 4;
  bool has_width() const;
  void clear_width();
  static const int kWidthFieldNumber = 4;
  ::google::protobuf::uint32 width() const;
  void set_width(::google::protobuf::uint32 value);

  // required uint32 height = 5;
  bool has_height() const;
  void clear_height();
  static const int kHeightFieldNumber = 5;
  ::google::protobuf::uint32 height() const;
  void set_height(::google::protobuf::uint32 value);

  // required uint32 mipmaps = 6;
  bool has_mipmaps() const;
  void clear_mipmaps();
  static const int kMipmapsFieldNumber = 6;
  ::google::protobuf::uint32 mipmaps() const;
  void set_mipmaps(::google::protobuf::uint32 value);

  // required uint32 size_in_bytes = 7;
  bool has_size_in_bytes() const;
  void clear_size_in_bytes();
  static const int kSizeInBytesFieldNumber = 7;
  ::google::protobuf::uint32 size_in_bytes() const;
  void set_size_in_bytes(::google::protobuf::uint32 value);

  // required uint32 pixel_format = 8;
  bool has_pixel_format() const;
  void clear_pixel_format();
  static const int kPixelFormatFieldNumber = 8;
  ::google::protobuf::uint32 pixel_format() const;
  void set_pixel_format(::google::protobuf::uint32 value);

  // required .NetworkPacket.SamplerType sampler_filter_type = 9;
  bool has_sampler_filter_type() const;
  void clear_sampler_filter_type();
  static const int kSamplerFilterTypeFieldNumber = 9;
  ::NetworkPacket::SamplerType sampler_filter_type() const;
  void set_sampler_filter_type(::NetworkPacket::SamplerType value);

  // @@protoc_insertion_point(class_scope:NetworkPacket.TextureResInfo)
 private:
  inline void set_has_res_name();
  inline void clear_has_res_name();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_res_id();
  inline void clear_has_res_id();
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_mipmaps();
  inline void clear_has_mipmaps();
  inline void set_has_size_in_bytes();
  inline void clear_has_size_in_bytes();
  inline void set_has_pixel_format();
  inline void clear_has_pixel_format();
  inline void set_has_sampler_filter_type();
  inline void clear_has_sampler_filter_type();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr res_name_;
  int type_;
  ::google::protobuf::uint32 res_id_;
  ::google::protobuf::uint32 width_;
  ::google::protobuf::uint32 height_;
  ::google::protobuf::uint32 mipmaps_;
  ::google::protobuf::uint32 size_in_bytes_;
  ::google::protobuf::uint32 pixel_format_;
  int sampler_filter_type_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_NetworkPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_NetworkPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_NetworkPacket_2eproto();
  friend void protobuf_ShutdownFile_NetworkPacket_2eproto();

  void InitAsDefaultInstance();
  static TextureResInfo* default_instance_;
};
// -------------------------------------------------------------------

class TextureChangeSamplerFilter : public ::google::protobuf::MessageLite {
 public:
  TextureChangeSamplerFilter();
  virtual ~TextureChangeSamplerFilter();

  TextureChangeSamplerFilter(const TextureChangeSamplerFilter& from);

  inline TextureChangeSamplerFilter& operator=(const TextureChangeSamplerFilter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const TextureChangeSamplerFilter& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TextureChangeSamplerFilter* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TextureChangeSamplerFilter* other);

  // implements Message ----------------------------------------------

  inline TextureChangeSamplerFilter* New() const { return New(NULL); }

  TextureChangeSamplerFilter* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TextureChangeSamplerFilter& from);
  void MergeFrom(const TextureChangeSamplerFilter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TextureChangeSamplerFilter* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 res_id = 1;
  bool has_res_id() const;
  void clear_res_id();
  static const int kResIdFieldNumber = 1;
  ::google::protobuf::uint32 res_id() const;
  void set_res_id(::google::protobuf::uint32 value);

  // required .NetworkPacket.SamplerType sampler_filter_type = 2;
  bool has_sampler_filter_type() const;
  void clear_sampler_filter_type();
  static const int kSamplerFilterTypeFieldNumber = 2;
  ::NetworkPacket::SamplerType sampler_filter_type() const;
  void set_sampler_filter_type(::NetworkPacket::SamplerType value);

  // @@protoc_insertion_point(class_scope:NetworkPacket.TextureChangeSamplerFilter)
 private:
  inline void set_has_res_id();
  inline void clear_has_res_id();
  inline void set_has_sampler_filter_type();
  inline void clear_has_sampler_filter_type();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 res_id_;
  int sampler_filter_type_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_NetworkPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_NetworkPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_NetworkPacket_2eproto();
  friend void protobuf_ShutdownFile_NetworkPacket_2eproto();

  void InitAsDefaultInstance();
  static TextureChangeSamplerFilter* default_instance_;
};
// -------------------------------------------------------------------

class DeviceTexResources : public ::google::protobuf::MessageLite {
 public:
  DeviceTexResources();
  virtual ~DeviceTexResources();

  DeviceTexResources(const DeviceTexResources& from);

  inline DeviceTexResources& operator=(const DeviceTexResources& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const DeviceTexResources& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DeviceTexResources* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DeviceTexResources* other);

  // implements Message ----------------------------------------------

  inline DeviceTexResources* New() const { return New(NULL); }

  DeviceTexResources* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DeviceTexResources& from);
  void MergeFrom(const DeviceTexResources& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceTexResources* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .NetworkPacket.UID uid = 1;
  bool has_uid() const;
  void clear_uid();
  static const int kUidFieldNumber = 1;
  const ::NetworkPacket::UID& uid() const;
  ::NetworkPacket::UID* mutable_uid();
  ::NetworkPacket::UID* release_uid();
  void set_allocated_uid(::NetworkPacket::UID* uid);

  // repeated .NetworkPacket.TextureResInfo textures = 2;
  int textures_size() const;
  void clear_textures();
  static const int kTexturesFieldNumber = 2;
  const ::NetworkPacket::TextureResInfo& textures(int index) const;
  ::NetworkPacket::TextureResInfo* mutable_textures(int index);
  ::NetworkPacket::TextureResInfo* add_textures();
  ::google::protobuf::RepeatedPtrField< ::NetworkPacket::TextureResInfo >*
      mutable_textures();
  const ::google::protobuf::RepeatedPtrField< ::NetworkPacket::TextureResInfo >&
      textures() const;

  // @@protoc_insertion_point(class_scope:NetworkPacket.DeviceTexResources)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::NetworkPacket::UID* uid_;
  ::google::protobuf::RepeatedPtrField< ::NetworkPacket::TextureResInfo > textures_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_NetworkPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_NetworkPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_NetworkPacket_2eproto();
  friend void protobuf_ShutdownFile_NetworkPacket_2eproto();

  void InitAsDefaultInstance();
  static DeviceTexResources* default_instance_;
};
// -------------------------------------------------------------------

class DeviceMemResInfo : public ::google::protobuf::MessageLite {
 public:
  DeviceMemResInfo();
  virtual ~DeviceMemResInfo();

  DeviceMemResInfo(const DeviceMemResInfo& from);

  inline DeviceMemResInfo& operator=(const DeviceMemResInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const DeviceMemResInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DeviceMemResInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DeviceMemResInfo* other);

  // implements Message ----------------------------------------------

  inline DeviceMemResInfo* New() const { return New(NULL); }

  DeviceMemResInfo* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DeviceMemResInfo& from);
  void MergeFrom(const DeviceMemResInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceMemResInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string file_name = 1;
  bool has_file_name() const;
  void clear_file_name();
  static const int kFileNameFieldNumber = 1;
  const ::std::string& file_name() const;
  void set_file_name(const ::std::string& value);
  void set_file_name(const char* value);
  void set_file_name(const char* value, size_t size);
  ::std::string* mutable_file_name();
  ::std::string* release_file_name();
  void set_allocated_file_name(::std::string* file_name);

  // required uint32 line_number = 2;
  bool has_line_number() const;
  void clear_line_number();
  static const int kLineNumberFieldNumber = 2;
  ::google::protobuf::uint32 line_number() const;
  void set_line_number(::google::protobuf::uint32 value);

  // required uint32 size_in_bytes = 3;
  bool has_size_in_bytes() const;
  void clear_size_in_bytes();
  static const int kSizeInBytesFieldNumber = 3;
  ::google::protobuf::uint32 size_in_bytes() const;
  void set_size_in_bytes(::google::protobuf::uint32 value);

  // optional uint32 number = 4;
  bool has_number() const;
  void clear_number();
  static const int kNumberFieldNumber = 4;
  ::google::protobuf::uint32 number() const;
  void set_number(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:NetworkPacket.DeviceMemResInfo)
 private:
  inline void set_has_file_name();
  inline void clear_has_file_name();
  inline void set_has_line_number();
  inline void clear_has_line_number();
  inline void set_has_size_in_bytes();
  inline void clear_has_size_in_bytes();
  inline void set_has_number();
  inline void clear_has_number();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr file_name_;
  ::google::protobuf::uint32 line_number_;
  ::google::protobuf::uint32 size_in_bytes_;
  ::google::protobuf::uint32 number_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_NetworkPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_NetworkPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_NetworkPacket_2eproto();
  friend void protobuf_ShutdownFile_NetworkPacket_2eproto();

  void InitAsDefaultInstance();
  static DeviceMemResInfo* default_instance_;
};
// -------------------------------------------------------------------

class DeviceMemResources : public ::google::protobuf::MessageLite {
 public:
  DeviceMemResources();
  virtual ~DeviceMemResources();

  DeviceMemResources(const DeviceMemResources& from);

  inline DeviceMemResources& operator=(const DeviceMemResources& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const DeviceMemResources& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DeviceMemResources* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DeviceMemResources* other);

  // implements Message ----------------------------------------------

  inline DeviceMemResources* New() const { return New(NULL); }

  DeviceMemResources* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DeviceMemResources& from);
  void MergeFrom(const DeviceMemResources& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceMemResources* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .NetworkPacket.UID uid = 1;
  bool has_uid() const;
  void clear_uid();
  static const int kUidFieldNumber = 1;
  const ::NetworkPacket::UID& uid() const;
  ::NetworkPacket::UID* mutable_uid();
  ::NetworkPacket::UID* release_uid();
  void set_allocated_uid(::NetworkPacket::UID* uid);

  // optional uint32 min_size = 2;
  bool has_min_size() const;
  void clear_min_size();
  static const int kMinSizeFieldNumber = 2;
  ::google::protobuf::uint32 min_size() const;
  void set_min_size(::google::protobuf::uint32 value);

  // optional uint32 total_alloc_size = 3;
  bool has_total_alloc_size() const;
  void clear_total_alloc_size();
  static const int kTotalAllocSizeFieldNumber = 3;
  ::google::protobuf::uint32 total_alloc_size() const;
  void set_total_alloc_size(::google::protobuf::uint32 value);

  // optional uint32 total_alloc_number = 4;
  bool has_total_alloc_number() const;
  void clear_total_alloc_number();
  static const int kTotalAllocNumberFieldNumber = 4;
  ::google::protobuf::uint32 total_alloc_number() const;
  void set_total_alloc_number(::google::protobuf::uint32 value);

  // repeated .NetworkPacket.DeviceMemResInfo resources = 5;
  int resources_size() const;
  void clear_resources();
  static const int kResourcesFieldNumber = 5;
  const ::NetworkPacket::DeviceMemResInfo& resources(int index) const;
  ::NetworkPacket::DeviceMemResInfo* mutable_resources(int index);
  ::NetworkPacket::DeviceMemResInfo* add_resources();
  ::google::protobuf::RepeatedPtrField< ::NetworkPacket::DeviceMemResInfo >*
      mutable_resources();
  const ::google::protobuf::RepeatedPtrField< ::NetworkPacket::DeviceMemResInfo >&
      resources() const;

  // @@protoc_insertion_point(class_scope:NetworkPacket.DeviceMemResources)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_min_size();
  inline void clear_has_min_size();
  inline void set_has_total_alloc_size();
  inline void clear_has_total_alloc_size();
  inline void set_has_total_alloc_number();
  inline void clear_has_total_alloc_number();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::NetworkPacket::UID* uid_;
  ::google::protobuf::uint32 min_size_;
  ::google::protobuf::uint32 total_alloc_size_;
  ::google::protobuf::RepeatedPtrField< ::NetworkPacket::DeviceMemResInfo > resources_;
  ::google::protobuf::uint32 total_alloc_number_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_NetworkPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_NetworkPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_NetworkPacket_2eproto();
  friend void protobuf_ShutdownFile_NetworkPacket_2eproto();

  void InitAsDefaultInstance();
  static DeviceMemResources* default_instance_;
};
// -------------------------------------------------------------------

class ShaderResInfo : public ::google::protobuf::MessageLite {
 public:
  ShaderResInfo();
  virtual ~ShaderResInfo();

  ShaderResInfo(const ShaderResInfo& from);

  inline ShaderResInfo& operator=(const ShaderResInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const ShaderResInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ShaderResInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ShaderResInfo* other);

  // implements Message ----------------------------------------------

  inline ShaderResInfo* New() const { return New(NULL); }

  ShaderResInfo* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ShaderResInfo& from);
  void MergeFrom(const ShaderResInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ShaderResInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required uint32 key = 2;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  ::google::protobuf::uint32 key() const;
  void set_key(::google::protobuf::uint32 value);

  // required string vs_code = 3;
  bool has_vs_code() const;
  void clear_vs_code();
  static const int kVsCodeFieldNumber = 3;
  const ::std::string& vs_code() const;
  void set_vs_code(const ::std::string& value);
  void set_vs_code(const char* value);
  void set_vs_code(const char* value, size_t size);
  ::std::string* mutable_vs_code();
  ::std::string* release_vs_code();
  void set_allocated_vs_code(::std::string* vs_code);

  // required string ps_code = 4;
  bool has_ps_code() const;
  void clear_ps_code();
  static const int kPsCodeFieldNumber = 4;
  const ::std::string& ps_code() const;
  void set_ps_code(const ::std::string& value);
  void set_ps_code(const char* value);
  void set_ps_code(const char* value, size_t size);
  ::std::string* mutable_ps_code();
  ::std::string* release_ps_code();
  void set_allocated_ps_code(::std::string* ps_code);

  // @@protoc_insertion_point(class_scope:NetworkPacket.ShaderResInfo)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_vs_code();
  inline void clear_has_vs_code();
  inline void set_has_ps_code();
  inline void clear_has_ps_code();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr vs_code_;
  ::google::protobuf::internal::ArenaStringPtr ps_code_;
  ::google::protobuf::uint32 key_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_NetworkPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_NetworkPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_NetworkPacket_2eproto();
  friend void protobuf_ShutdownFile_NetworkPacket_2eproto();

  void InitAsDefaultInstance();
  static ShaderResInfo* default_instance_;
};
// -------------------------------------------------------------------

class DeviceShaderResources : public ::google::protobuf::MessageLite {
 public:
  DeviceShaderResources();
  virtual ~DeviceShaderResources();

  DeviceShaderResources(const DeviceShaderResources& from);

  inline DeviceShaderResources& operator=(const DeviceShaderResources& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const DeviceShaderResources& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DeviceShaderResources* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DeviceShaderResources* other);

  // implements Message ----------------------------------------------

  inline DeviceShaderResources* New() const { return New(NULL); }

  DeviceShaderResources* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DeviceShaderResources& from);
  void MergeFrom(const DeviceShaderResources& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceShaderResources* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .NetworkPacket.UID uid = 1;
  bool has_uid() const;
  void clear_uid();
  static const int kUidFieldNumber = 1;
  const ::NetworkPacket::UID& uid() const;
  ::NetworkPacket::UID* mutable_uid();
  ::NetworkPacket::UID* release_uid();
  void set_allocated_uid(::NetworkPacket::UID* uid);

  // repeated .NetworkPacket.ShaderResInfo shaders = 2;
  int shaders_size() const;
  void clear_shaders();
  static const int kShadersFieldNumber = 2;
  const ::NetworkPacket::ShaderResInfo& shaders(int index) const;
  ::NetworkPacket::ShaderResInfo* mutable_shaders(int index);
  ::NetworkPacket::ShaderResInfo* add_shaders();
  ::google::protobuf::RepeatedPtrField< ::NetworkPacket::ShaderResInfo >*
      mutable_shaders();
  const ::google::protobuf::RepeatedPtrField< ::NetworkPacket::ShaderResInfo >&
      shaders() const;

  // @@protoc_insertion_point(class_scope:NetworkPacket.DeviceShaderResources)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::NetworkPacket::UID* uid_;
  ::google::protobuf::RepeatedPtrField< ::NetworkPacket::ShaderResInfo > shaders_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_NetworkPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_NetworkPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_NetworkPacket_2eproto();
  friend void protobuf_ShutdownFile_NetworkPacket_2eproto();

  void InitAsDefaultInstance();
  static DeviceShaderResources* default_instance_;
};
// -------------------------------------------------------------------

class GUIResInfo : public ::google::protobuf::MessageLite {
 public:
  GUIResInfo();
  virtual ~GUIResInfo();

  GUIResInfo(const GUIResInfo& from);

  inline GUIResInfo& operator=(const GUIResInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const GUIResInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GUIResInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GUIResInfo* other);

  // implements Message ----------------------------------------------

  inline GUIResInfo* New() const { return New(NULL); }

  GUIResInfo* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GUIResInfo& from);
  void MergeFrom(const GUIResInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GUIResInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string gui_controls = 1;
  bool has_gui_controls() const;
  void clear_gui_controls();
  static const int kGuiControlsFieldNumber = 1;
  const ::std::string& gui_controls() const;
  void set_gui_controls(const ::std::string& value);
  void set_gui_controls(const char* value);
  void set_gui_controls(const char* value, size_t size);
  ::std::string* mutable_gui_controls();
  ::std::string* release_gui_controls();
  void set_allocated_gui_controls(::std::string* gui_controls);

  // @@protoc_insertion_point(class_scope:NetworkPacket.GUIResInfo)
 private:
  inline void set_has_gui_controls();
  inline void clear_has_gui_controls();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr gui_controls_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_NetworkPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_NetworkPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_NetworkPacket_2eproto();
  friend void protobuf_ShutdownFile_NetworkPacket_2eproto();

  void InitAsDefaultInstance();
  static GUIResInfo* default_instance_;
};
// -------------------------------------------------------------------

class PerformanceInfo : public ::google::protobuf::MessageLite {
 public:
  PerformanceInfo();
  virtual ~PerformanceInfo();

  PerformanceInfo(const PerformanceInfo& from);

  inline PerformanceInfo& operator=(const PerformanceInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const PerformanceInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PerformanceInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PerformanceInfo* other);

  // implements Message ----------------------------------------------

  inline PerformanceInfo* New() const { return New(NULL); }

  PerformanceInfo* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PerformanceInfo& from);
  void MergeFrom(const PerformanceInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PerformanceInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .NetworkPacket.UID uid = 1;
  bool has_uid() const;
  void clear_uid();
  static const int kUidFieldNumber = 1;
  const ::NetworkPacket::UID& uid() const;
  ::NetworkPacket::UID* mutable_uid();
  ::NetworkPacket::UID* release_uid();
  void set_allocated_uid(::NetworkPacket::UID* uid);

  // required uint64 file_open_count = 2;
  bool has_file_open_count() const;
  void clear_file_open_count();
  static const int kFileOpenCountFieldNumber = 2;
  ::google::protobuf::uint64 file_open_count() const;
  void set_file_open_count(::google::protobuf::uint64 value);

  // required uint64 file_read_count = 3;
  bool has_file_read_count() const;
  void clear_file_read_count();
  static const int kFileReadCountFieldNumber = 3;
  ::google::protobuf::uint64 file_read_count() const;
  void set_file_read_count(::google::protobuf::uint64 value);

  // required uint64 file_read_bytes = 4;
  bool has_file_read_bytes() const;
  void clear_file_read_bytes();
  static const int kFileReadBytesFieldNumber = 4;
  ::google::protobuf::uint64 file_read_bytes() const;
  void set_file_read_bytes(::google::protobuf::uint64 value);

  // required uint64 file_write_count = 5;
  bool has_file_write_count() const;
  void clear_file_write_count();
  static const int kFileWriteCountFieldNumber = 5;
  ::google::protobuf::uint64 file_write_count() const;
  void set_file_write_count(::google::protobuf::uint64 value);

  // required uint64 file_write_bytes = 6;
  bool has_file_write_bytes() const;
  void clear_file_write_bytes();
  static const int kFileWriteBytesFieldNumber = 6;
  ::google::protobuf::uint64 file_write_bytes() const;
  void set_file_write_bytes(::google::protobuf::uint64 value);

  // required uint64 gl_api_count = 7;
  bool has_gl_api_count() const;
  void clear_gl_api_count();
  static const int kGlApiCountFieldNumber = 7;
  ::google::protobuf::uint64 gl_api_count() const;
  void set_gl_api_count(::google::protobuf::uint64 value);

  // required uint64 gl_dp_count = 8;
  bool has_gl_dp_count() const;
  void clear_gl_dp_count();
  static const int kGlDpCountFieldNumber = 8;
  ::google::protobuf::uint64 gl_dp_count() const;
  void set_gl_dp_count(::google::protobuf::uint64 value);

  // required uint64 gl_compressed_tex_count = 9;
  bool has_gl_compressed_tex_count() const;
  void clear_gl_compressed_tex_count();
  static const int kGlCompressedTexCountFieldNumber = 9;
  ::google::protobuf::uint64 gl_compressed_tex_count() const;
  void set_gl_compressed_tex_count(::google::protobuf::uint64 value);

  // required uint64 gl_tex_count = 10;
  bool has_gl_tex_count() const;
  void clear_gl_tex_count();
  static const int kGlTexCountFieldNumber = 10;
  ::google::protobuf::uint64 gl_tex_count() const;
  void set_gl_tex_count(::google::protobuf::uint64 value);

  // required uint64 gl_tex_bytes = 11;
  bool has_gl_tex_bytes() const;
  void clear_gl_tex_bytes();
  static const int kGlTexBytesFieldNumber = 11;
  ::google::protobuf::uint64 gl_tex_bytes() const;
  void set_gl_tex_bytes(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:NetworkPacket.PerformanceInfo)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_file_open_count();
  inline void clear_has_file_open_count();
  inline void set_has_file_read_count();
  inline void clear_has_file_read_count();
  inline void set_has_file_read_bytes();
  inline void clear_has_file_read_bytes();
  inline void set_has_file_write_count();
  inline void clear_has_file_write_count();
  inline void set_has_file_write_bytes();
  inline void clear_has_file_write_bytes();
  inline void set_has_gl_api_count();
  inline void clear_has_gl_api_count();
  inline void set_has_gl_dp_count();
  inline void clear_has_gl_dp_count();
  inline void set_has_gl_compressed_tex_count();
  inline void clear_has_gl_compressed_tex_count();
  inline void set_has_gl_tex_count();
  inline void clear_has_gl_tex_count();
  inline void set_has_gl_tex_bytes();
  inline void clear_has_gl_tex_bytes();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::NetworkPacket::UID* uid_;
  ::google::protobuf::uint64 file_open_count_;
  ::google::protobuf::uint64 file_read_count_;
  ::google::protobuf::uint64 file_read_bytes_;
  ::google::protobuf::uint64 file_write_count_;
  ::google::protobuf::uint64 file_write_bytes_;
  ::google::protobuf::uint64 gl_api_count_;
  ::google::protobuf::uint64 gl_dp_count_;
  ::google::protobuf::uint64 gl_compressed_tex_count_;
  ::google::protobuf::uint64 gl_tex_count_;
  ::google::protobuf::uint64 gl_tex_bytes_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_NetworkPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_NetworkPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_NetworkPacket_2eproto();
  friend void protobuf_ShutdownFile_NetworkPacket_2eproto();

  void InitAsDefaultInstance();
  static PerformanceInfo* default_instance_;
};
// -------------------------------------------------------------------

class PerformanceParticlesInfo : public ::google::protobuf::MessageLite {
 public:
  PerformanceParticlesInfo();
  virtual ~PerformanceParticlesInfo();

  PerformanceParticlesInfo(const PerformanceParticlesInfo& from);

  inline PerformanceParticlesInfo& operator=(const PerformanceParticlesInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const PerformanceParticlesInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PerformanceParticlesInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PerformanceParticlesInfo* other);

  // implements Message ----------------------------------------------

  inline PerformanceParticlesInfo* New() const { return New(NULL); }

  PerformanceParticlesInfo* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PerformanceParticlesInfo& from);
  void MergeFrom(const PerformanceParticlesInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PerformanceParticlesInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool enable = 1;
  bool has_enable() const;
  void clear_enable();
  static const int kEnableFieldNumber = 1;
  bool enable() const;
  void set_enable(bool value);

  // @@protoc_insertion_point(class_scope:NetworkPacket.PerformanceParticlesInfo)
 private:
  inline void set_has_enable();
  inline void clear_has_enable();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool enable_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_NetworkPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_NetworkPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_NetworkPacket_2eproto();
  friend void protobuf_ShutdownFile_NetworkPacket_2eproto();

  void InitAsDefaultInstance();
  static PerformanceParticlesInfo* default_instance_;
};
// -------------------------------------------------------------------

class PerformanceGlobalShaderInfo : public ::google::protobuf::MessageLite {
 public:
  PerformanceGlobalShaderInfo();
  virtual ~PerformanceGlobalShaderInfo();

  PerformanceGlobalShaderInfo(const PerformanceGlobalShaderInfo& from);

  inline PerformanceGlobalShaderInfo& operator=(const PerformanceGlobalShaderInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const PerformanceGlobalShaderInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PerformanceGlobalShaderInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PerformanceGlobalShaderInfo* other);

  // implements Message ----------------------------------------------

  inline PerformanceGlobalShaderInfo* New() const { return New(NULL); }

  PerformanceGlobalShaderInfo* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PerformanceGlobalShaderInfo& from);
  void MergeFrom(const PerformanceGlobalShaderInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PerformanceGlobalShaderInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:NetworkPacket.PerformanceGlobalShaderInfo)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_NetworkPacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_NetworkPacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_NetworkPacket_2eproto();
  friend void protobuf_ShutdownFile_NetworkPacket_2eproto();

  void InitAsDefaultInstance();
  static PerformanceGlobalShaderInfo* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// KeepAliveInfo

// required uint32 number = 1;
inline bool KeepAliveInfo::has_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KeepAliveInfo::set_has_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KeepAliveInfo::clear_has_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KeepAliveInfo::clear_number() {
  number_ = 0u;
  clear_has_number();
}
inline ::google::protobuf::uint32 KeepAliveInfo::number() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.KeepAliveInfo.number)
  return number_;
}
inline void KeepAliveInfo::set_number(::google::protobuf::uint32 value) {
  set_has_number();
  number_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.KeepAliveInfo.number)
}

// -------------------------------------------------------------------

// UID

// required uint32 data1 = 1;
inline bool UID::has_data1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UID::set_has_data1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UID::clear_has_data1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UID::clear_data1() {
  data1_ = 0u;
  clear_has_data1();
}
inline ::google::protobuf::uint32 UID::data1() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.UID.data1)
  return data1_;
}
inline void UID::set_data1(::google::protobuf::uint32 value) {
  set_has_data1();
  data1_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.UID.data1)
}

// required uint32 data2 = 2;
inline bool UID::has_data2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UID::set_has_data2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UID::clear_has_data2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UID::clear_data2() {
  data2_ = 0u;
  clear_has_data2();
}
inline ::google::protobuf::uint32 UID::data2() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.UID.data2)
  return data2_;
}
inline void UID::set_data2(::google::protobuf::uint32 value) {
  set_has_data2();
  data2_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.UID.data2)
}

// required uint32 data3 = 3;
inline bool UID::has_data3() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UID::set_has_data3() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UID::clear_has_data3() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UID::clear_data3() {
  data3_ = 0u;
  clear_has_data3();
}
inline ::google::protobuf::uint32 UID::data3() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.UID.data3)
  return data3_;
}
inline void UID::set_data3(::google::protobuf::uint32 value) {
  set_has_data3();
  data3_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.UID.data3)
}

// required uint32 data4 = 4;
inline bool UID::has_data4() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UID::set_has_data4() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UID::clear_has_data4() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UID::clear_data4() {
  data4_ = 0u;
  clear_has_data4();
}
inline ::google::protobuf::uint32 UID::data4() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.UID.data4)
  return data4_;
}
inline void UID::set_data4(::google::protobuf::uint32 value) {
  set_has_data4();
  data4_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.UID.data4)
}

// -------------------------------------------------------------------

// DeviceInfo

// required .NetworkPacket.UID uid = 1;
inline bool DeviceInfo::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceInfo::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeviceInfo::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeviceInfo::clear_uid() {
  if (uid_ != NULL) uid_->::NetworkPacket::UID::Clear();
  clear_has_uid();
}
inline const ::NetworkPacket::UID& DeviceInfo::uid() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.DeviceInfo.uid)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return uid_ != NULL ? *uid_ : *default_instance().uid_;
#else
  return uid_ != NULL ? *uid_ : *default_instance_->uid_;
#endif
}
inline ::NetworkPacket::UID* DeviceInfo::mutable_uid() {
  set_has_uid();
  if (uid_ == NULL) {
    uid_ = new ::NetworkPacket::UID;
  }
  // @@protoc_insertion_point(field_mutable:NetworkPacket.DeviceInfo.uid)
  return uid_;
}
inline ::NetworkPacket::UID* DeviceInfo::release_uid() {
  // @@protoc_insertion_point(field_release:NetworkPacket.DeviceInfo.uid)
  clear_has_uid();
  ::NetworkPacket::UID* temp = uid_;
  uid_ = NULL;
  return temp;
}
inline void DeviceInfo::set_allocated_uid(::NetworkPacket::UID* uid) {
  delete uid_;
  uid_ = uid;
  if (uid) {
    set_has_uid();
  } else {
    clear_has_uid();
  }
  // @@protoc_insertion_point(field_set_allocated:NetworkPacket.DeviceInfo.uid)
}

// required uint32 process_id = 2;
inline bool DeviceInfo::has_process_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeviceInfo::set_has_process_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DeviceInfo::clear_has_process_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DeviceInfo::clear_process_id() {
  process_id_ = 0u;
  clear_has_process_id();
}
inline ::google::protobuf::uint32 DeviceInfo::process_id() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.DeviceInfo.process_id)
  return process_id_;
}
inline void DeviceInfo::set_process_id(::google::protobuf::uint32 value) {
  set_has_process_id();
  process_id_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.DeviceInfo.process_id)
}

// required string brand_name = 3;
inline bool DeviceInfo::has_brand_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DeviceInfo::set_has_brand_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DeviceInfo::clear_has_brand_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DeviceInfo::clear_brand_name() {
  brand_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_brand_name();
}
inline const ::std::string& DeviceInfo::brand_name() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.DeviceInfo.brand_name)
  return brand_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceInfo::set_brand_name(const ::std::string& value) {
  set_has_brand_name();
  brand_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NetworkPacket.DeviceInfo.brand_name)
}
inline void DeviceInfo::set_brand_name(const char* value) {
  set_has_brand_name();
  brand_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NetworkPacket.DeviceInfo.brand_name)
}
inline void DeviceInfo::set_brand_name(const char* value, size_t size) {
  set_has_brand_name();
  brand_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NetworkPacket.DeviceInfo.brand_name)
}
inline ::std::string* DeviceInfo::mutable_brand_name() {
  set_has_brand_name();
  // @@protoc_insertion_point(field_mutable:NetworkPacket.DeviceInfo.brand_name)
  return brand_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeviceInfo::release_brand_name() {
  // @@protoc_insertion_point(field_release:NetworkPacket.DeviceInfo.brand_name)
  clear_has_brand_name();
  return brand_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceInfo::set_allocated_brand_name(::std::string* brand_name) {
  if (brand_name != NULL) {
    set_has_brand_name();
  } else {
    clear_has_brand_name();
  }
  brand_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), brand_name);
  // @@protoc_insertion_point(field_set_allocated:NetworkPacket.DeviceInfo.brand_name)
}

// required string device_name = 4;
inline bool DeviceInfo::has_device_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DeviceInfo::set_has_device_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DeviceInfo::clear_has_device_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DeviceInfo::clear_device_name() {
  device_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_device_name();
}
inline const ::std::string& DeviceInfo::device_name() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.DeviceInfo.device_name)
  return device_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceInfo::set_device_name(const ::std::string& value) {
  set_has_device_name();
  device_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NetworkPacket.DeviceInfo.device_name)
}
inline void DeviceInfo::set_device_name(const char* value) {
  set_has_device_name();
  device_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NetworkPacket.DeviceInfo.device_name)
}
inline void DeviceInfo::set_device_name(const char* value, size_t size) {
  set_has_device_name();
  device_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NetworkPacket.DeviceInfo.device_name)
}
inline ::std::string* DeviceInfo::mutable_device_name() {
  set_has_device_name();
  // @@protoc_insertion_point(field_mutable:NetworkPacket.DeviceInfo.device_name)
  return device_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeviceInfo::release_device_name() {
  // @@protoc_insertion_point(field_release:NetworkPacket.DeviceInfo.device_name)
  clear_has_device_name();
  return device_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceInfo::set_allocated_device_name(::std::string* device_name) {
  if (device_name != NULL) {
    set_has_device_name();
  } else {
    clear_has_device_name();
  }
  device_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), device_name);
  // @@protoc_insertion_point(field_set_allocated:NetworkPacket.DeviceInfo.device_name)
}

// required string cpu_name = 5;
inline bool DeviceInfo::has_cpu_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DeviceInfo::set_has_cpu_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DeviceInfo::clear_has_cpu_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DeviceInfo::clear_cpu_name() {
  cpu_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_cpu_name();
}
inline const ::std::string& DeviceInfo::cpu_name() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.DeviceInfo.cpu_name)
  return cpu_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceInfo::set_cpu_name(const ::std::string& value) {
  set_has_cpu_name();
  cpu_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NetworkPacket.DeviceInfo.cpu_name)
}
inline void DeviceInfo::set_cpu_name(const char* value) {
  set_has_cpu_name();
  cpu_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NetworkPacket.DeviceInfo.cpu_name)
}
inline void DeviceInfo::set_cpu_name(const char* value, size_t size) {
  set_has_cpu_name();
  cpu_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NetworkPacket.DeviceInfo.cpu_name)
}
inline ::std::string* DeviceInfo::mutable_cpu_name() {
  set_has_cpu_name();
  // @@protoc_insertion_point(field_mutable:NetworkPacket.DeviceInfo.cpu_name)
  return cpu_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeviceInfo::release_cpu_name() {
  // @@protoc_insertion_point(field_release:NetworkPacket.DeviceInfo.cpu_name)
  clear_has_cpu_name();
  return cpu_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceInfo::set_allocated_cpu_name(::std::string* cpu_name) {
  if (cpu_name != NULL) {
    set_has_cpu_name();
  } else {
    clear_has_cpu_name();
  }
  cpu_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cpu_name);
  // @@protoc_insertion_point(field_set_allocated:NetworkPacket.DeviceInfo.cpu_name)
}

// required uint32 cpu_core_number = 6;
inline bool DeviceInfo::has_cpu_core_number() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DeviceInfo::set_has_cpu_core_number() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DeviceInfo::clear_has_cpu_core_number() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DeviceInfo::clear_cpu_core_number() {
  cpu_core_number_ = 0u;
  clear_has_cpu_core_number();
}
inline ::google::protobuf::uint32 DeviceInfo::cpu_core_number() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.DeviceInfo.cpu_core_number)
  return cpu_core_number_;
}
inline void DeviceInfo::set_cpu_core_number(::google::protobuf::uint32 value) {
  set_has_cpu_core_number();
  cpu_core_number_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.DeviceInfo.cpu_core_number)
}

// required string gpu_name = 7;
inline bool DeviceInfo::has_gpu_name() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DeviceInfo::set_has_gpu_name() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DeviceInfo::clear_has_gpu_name() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DeviceInfo::clear_gpu_name() {
  gpu_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_gpu_name();
}
inline const ::std::string& DeviceInfo::gpu_name() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.DeviceInfo.gpu_name)
  return gpu_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceInfo::set_gpu_name(const ::std::string& value) {
  set_has_gpu_name();
  gpu_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NetworkPacket.DeviceInfo.gpu_name)
}
inline void DeviceInfo::set_gpu_name(const char* value) {
  set_has_gpu_name();
  gpu_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NetworkPacket.DeviceInfo.gpu_name)
}
inline void DeviceInfo::set_gpu_name(const char* value, size_t size) {
  set_has_gpu_name();
  gpu_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NetworkPacket.DeviceInfo.gpu_name)
}
inline ::std::string* DeviceInfo::mutable_gpu_name() {
  set_has_gpu_name();
  // @@protoc_insertion_point(field_mutable:NetworkPacket.DeviceInfo.gpu_name)
  return gpu_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeviceInfo::release_gpu_name() {
  // @@protoc_insertion_point(field_release:NetworkPacket.DeviceInfo.gpu_name)
  clear_has_gpu_name();
  return gpu_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceInfo::set_allocated_gpu_name(::std::string* gpu_name) {
  if (gpu_name != NULL) {
    set_has_gpu_name();
  } else {
    clear_has_gpu_name();
  }
  gpu_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), gpu_name);
  // @@protoc_insertion_point(field_set_allocated:NetworkPacket.DeviceInfo.gpu_name)
}

// required uint32 gpu_core_number = 8;
inline bool DeviceInfo::has_gpu_core_number() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DeviceInfo::set_has_gpu_core_number() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DeviceInfo::clear_has_gpu_core_number() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DeviceInfo::clear_gpu_core_number() {
  gpu_core_number_ = 0u;
  clear_has_gpu_core_number();
}
inline ::google::protobuf::uint32 DeviceInfo::gpu_core_number() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.DeviceInfo.gpu_core_number)
  return gpu_core_number_;
}
inline void DeviceInfo::set_gpu_core_number(::google::protobuf::uint32 value) {
  set_has_gpu_core_number();
  gpu_core_number_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.DeviceInfo.gpu_core_number)
}

// required uint64 smem_size = 9;
inline bool DeviceInfo::has_smem_size() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DeviceInfo::set_has_smem_size() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DeviceInfo::clear_has_smem_size() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DeviceInfo::clear_smem_size() {
  smem_size_ = GOOGLE_ULONGLONG(0);
  clear_has_smem_size();
}
inline ::google::protobuf::uint64 DeviceInfo::smem_size() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.DeviceInfo.smem_size)
  return smem_size_;
}
inline void DeviceInfo::set_smem_size(::google::protobuf::uint64 value) {
  set_has_smem_size();
  smem_size_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.DeviceInfo.smem_size)
}

// required uint64 vmem_size = 10;
inline bool DeviceInfo::has_vmem_size() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DeviceInfo::set_has_vmem_size() {
  _has_bits_[0] |= 0x00000200u;
}
inline void DeviceInfo::clear_has_vmem_size() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void DeviceInfo::clear_vmem_size() {
  vmem_size_ = GOOGLE_ULONGLONG(0);
  clear_has_vmem_size();
}
inline ::google::protobuf::uint64 DeviceInfo::vmem_size() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.DeviceInfo.vmem_size)
  return vmem_size_;
}
inline void DeviceInfo::set_vmem_size(::google::protobuf::uint64 value) {
  set_has_vmem_size();
  vmem_size_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.DeviceInfo.vmem_size)
}

// -------------------------------------------------------------------

// DeviceRunTimeInfo

// required .NetworkPacket.UID uid = 1;
inline bool DeviceRunTimeInfo::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceRunTimeInfo::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeviceRunTimeInfo::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeviceRunTimeInfo::clear_uid() {
  if (uid_ != NULL) uid_->::NetworkPacket::UID::Clear();
  clear_has_uid();
}
inline const ::NetworkPacket::UID& DeviceRunTimeInfo::uid() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.DeviceRunTimeInfo.uid)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return uid_ != NULL ? *uid_ : *default_instance().uid_;
#else
  return uid_ != NULL ? *uid_ : *default_instance_->uid_;
#endif
}
inline ::NetworkPacket::UID* DeviceRunTimeInfo::mutable_uid() {
  set_has_uid();
  if (uid_ == NULL) {
    uid_ = new ::NetworkPacket::UID;
  }
  // @@protoc_insertion_point(field_mutable:NetworkPacket.DeviceRunTimeInfo.uid)
  return uid_;
}
inline ::NetworkPacket::UID* DeviceRunTimeInfo::release_uid() {
  // @@protoc_insertion_point(field_release:NetworkPacket.DeviceRunTimeInfo.uid)
  clear_has_uid();
  ::NetworkPacket::UID* temp = uid_;
  uid_ = NULL;
  return temp;
}
inline void DeviceRunTimeInfo::set_allocated_uid(::NetworkPacket::UID* uid) {
  delete uid_;
  uid_ = uid;
  if (uid) {
    set_has_uid();
  } else {
    clear_has_uid();
  }
  // @@protoc_insertion_point(field_set_allocated:NetworkPacket.DeviceRunTimeInfo.uid)
}

// required float fps = 2;
inline bool DeviceRunTimeInfo::has_fps() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeviceRunTimeInfo::set_has_fps() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DeviceRunTimeInfo::clear_has_fps() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DeviceRunTimeInfo::clear_fps() {
  fps_ = 0;
  clear_has_fps();
}
inline float DeviceRunTimeInfo::fps() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.DeviceRunTimeInfo.fps)
  return fps_;
}
inline void DeviceRunTimeInfo::set_fps(float value) {
  set_has_fps();
  fps_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.DeviceRunTimeInfo.fps)
}

// required uint64 smem_size = 3;
inline bool DeviceRunTimeInfo::has_smem_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DeviceRunTimeInfo::set_has_smem_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DeviceRunTimeInfo::clear_has_smem_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DeviceRunTimeInfo::clear_smem_size() {
  smem_size_ = GOOGLE_ULONGLONG(0);
  clear_has_smem_size();
}
inline ::google::protobuf::uint64 DeviceRunTimeInfo::smem_size() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.DeviceRunTimeInfo.smem_size)
  return smem_size_;
}
inline void DeviceRunTimeInfo::set_smem_size(::google::protobuf::uint64 value) {
  set_has_smem_size();
  smem_size_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.DeviceRunTimeInfo.smem_size)
}

// required uint64 vmem_size = 4;
inline bool DeviceRunTimeInfo::has_vmem_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DeviceRunTimeInfo::set_has_vmem_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DeviceRunTimeInfo::clear_has_vmem_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DeviceRunTimeInfo::clear_vmem_size() {
  vmem_size_ = GOOGLE_ULONGLONG(0);
  clear_has_vmem_size();
}
inline ::google::protobuf::uint64 DeviceRunTimeInfo::vmem_size() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.DeviceRunTimeInfo.vmem_size)
  return vmem_size_;
}
inline void DeviceRunTimeInfo::set_vmem_size(::google::protobuf::uint64 value) {
  set_has_vmem_size();
  vmem_size_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.DeviceRunTimeInfo.vmem_size)
}

// required float cpu_usage = 5;
inline bool DeviceRunTimeInfo::has_cpu_usage() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DeviceRunTimeInfo::set_has_cpu_usage() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DeviceRunTimeInfo::clear_has_cpu_usage() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DeviceRunTimeInfo::clear_cpu_usage() {
  cpu_usage_ = 0;
  clear_has_cpu_usage();
}
inline float DeviceRunTimeInfo::cpu_usage() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.DeviceRunTimeInfo.cpu_usage)
  return cpu_usage_;
}
inline void DeviceRunTimeInfo::set_cpu_usage(float value) {
  set_has_cpu_usage();
  cpu_usage_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.DeviceRunTimeInfo.cpu_usage)
}

// required float gpu_usage = 6;
inline bool DeviceRunTimeInfo::has_gpu_usage() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DeviceRunTimeInfo::set_has_gpu_usage() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DeviceRunTimeInfo::clear_has_gpu_usage() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DeviceRunTimeInfo::clear_gpu_usage() {
  gpu_usage_ = 0;
  clear_has_gpu_usage();
}
inline float DeviceRunTimeInfo::gpu_usage() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.DeviceRunTimeInfo.gpu_usage)
  return gpu_usage_;
}
inline void DeviceRunTimeInfo::set_gpu_usage(float value) {
  set_has_gpu_usage();
  gpu_usage_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.DeviceRunTimeInfo.gpu_usage)
}

// -------------------------------------------------------------------

// LoginInfo

// required .NetworkPacket.DeviceInfo device = 1;
inline bool LoginInfo::has_device() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginInfo::set_has_device() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginInfo::clear_has_device() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginInfo::clear_device() {
  if (device_ != NULL) device_->::NetworkPacket::DeviceInfo::Clear();
  clear_has_device();
}
inline const ::NetworkPacket::DeviceInfo& LoginInfo::device() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.LoginInfo.device)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return device_ != NULL ? *device_ : *default_instance().device_;
#else
  return device_ != NULL ? *device_ : *default_instance_->device_;
#endif
}
inline ::NetworkPacket::DeviceInfo* LoginInfo::mutable_device() {
  set_has_device();
  if (device_ == NULL) {
    device_ = new ::NetworkPacket::DeviceInfo;
  }
  // @@protoc_insertion_point(field_mutable:NetworkPacket.LoginInfo.device)
  return device_;
}
inline ::NetworkPacket::DeviceInfo* LoginInfo::release_device() {
  // @@protoc_insertion_point(field_release:NetworkPacket.LoginInfo.device)
  clear_has_device();
  ::NetworkPacket::DeviceInfo* temp = device_;
  device_ = NULL;
  return temp;
}
inline void LoginInfo::set_allocated_device(::NetworkPacket::DeviceInfo* device) {
  delete device_;
  device_ = device;
  if (device) {
    set_has_device();
  } else {
    clear_has_device();
  }
  // @@protoc_insertion_point(field_set_allocated:NetworkPacket.LoginInfo.device)
}

// -------------------------------------------------------------------

// LogoutInfo

// required .NetworkPacket.DeviceInfo device = 1;
inline bool LogoutInfo::has_device() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogoutInfo::set_has_device() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogoutInfo::clear_has_device() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogoutInfo::clear_device() {
  if (device_ != NULL) device_->::NetworkPacket::DeviceInfo::Clear();
  clear_has_device();
}
inline const ::NetworkPacket::DeviceInfo& LogoutInfo::device() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.LogoutInfo.device)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return device_ != NULL ? *device_ : *default_instance().device_;
#else
  return device_ != NULL ? *device_ : *default_instance_->device_;
#endif
}
inline ::NetworkPacket::DeviceInfo* LogoutInfo::mutable_device() {
  set_has_device();
  if (device_ == NULL) {
    device_ = new ::NetworkPacket::DeviceInfo;
  }
  // @@protoc_insertion_point(field_mutable:NetworkPacket.LogoutInfo.device)
  return device_;
}
inline ::NetworkPacket::DeviceInfo* LogoutInfo::release_device() {
  // @@protoc_insertion_point(field_release:NetworkPacket.LogoutInfo.device)
  clear_has_device();
  ::NetworkPacket::DeviceInfo* temp = device_;
  device_ = NULL;
  return temp;
}
inline void LogoutInfo::set_allocated_device(::NetworkPacket::DeviceInfo* device) {
  delete device_;
  device_ = device;
  if (device) {
    set_has_device();
  } else {
    clear_has_device();
  }
  // @@protoc_insertion_point(field_set_allocated:NetworkPacket.LogoutInfo.device)
}

// -------------------------------------------------------------------

// ThreadInfo

// required uint64 id = 1;
inline bool ThreadInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ThreadInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ThreadInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ThreadInfo::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 ThreadInfo::id() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.ThreadInfo.id)
  return id_;
}
inline void ThreadInfo::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.ThreadInfo.id)
}

// required string name = 2;
inline bool ThreadInfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ThreadInfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ThreadInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ThreadInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& ThreadInfo::name() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.ThreadInfo.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ThreadInfo::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NetworkPacket.ThreadInfo.name)
}
inline void ThreadInfo::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NetworkPacket.ThreadInfo.name)
}
inline void ThreadInfo::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NetworkPacket.ThreadInfo.name)
}
inline ::std::string* ThreadInfo::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:NetworkPacket.ThreadInfo.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ThreadInfo::release_name() {
  // @@protoc_insertion_point(field_release:NetworkPacket.ThreadInfo.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ThreadInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:NetworkPacket.ThreadInfo.name)
}

// required float cpu_usage = 3;
inline bool ThreadInfo::has_cpu_usage() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ThreadInfo::set_has_cpu_usage() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ThreadInfo::clear_has_cpu_usage() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ThreadInfo::clear_cpu_usage() {
  cpu_usage_ = 0;
  clear_has_cpu_usage();
}
inline float ThreadInfo::cpu_usage() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.ThreadInfo.cpu_usage)
  return cpu_usage_;
}
inline void ThreadInfo::set_cpu_usage(float value) {
  set_has_cpu_usage();
  cpu_usage_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.ThreadInfo.cpu_usage)
}

// -------------------------------------------------------------------

// ThreadsInfo

// required .NetworkPacket.UID uid = 1;
inline bool ThreadsInfo::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ThreadsInfo::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ThreadsInfo::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ThreadsInfo::clear_uid() {
  if (uid_ != NULL) uid_->::NetworkPacket::UID::Clear();
  clear_has_uid();
}
inline const ::NetworkPacket::UID& ThreadsInfo::uid() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.ThreadsInfo.uid)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return uid_ != NULL ? *uid_ : *default_instance().uid_;
#else
  return uid_ != NULL ? *uid_ : *default_instance_->uid_;
#endif
}
inline ::NetworkPacket::UID* ThreadsInfo::mutable_uid() {
  set_has_uid();
  if (uid_ == NULL) {
    uid_ = new ::NetworkPacket::UID;
  }
  // @@protoc_insertion_point(field_mutable:NetworkPacket.ThreadsInfo.uid)
  return uid_;
}
inline ::NetworkPacket::UID* ThreadsInfo::release_uid() {
  // @@protoc_insertion_point(field_release:NetworkPacket.ThreadsInfo.uid)
  clear_has_uid();
  ::NetworkPacket::UID* temp = uid_;
  uid_ = NULL;
  return temp;
}
inline void ThreadsInfo::set_allocated_uid(::NetworkPacket::UID* uid) {
  delete uid_;
  uid_ = uid;
  if (uid) {
    set_has_uid();
  } else {
    clear_has_uid();
  }
  // @@protoc_insertion_point(field_set_allocated:NetworkPacket.ThreadsInfo.uid)
}

// repeated .NetworkPacket.ThreadInfo threads = 2;
inline int ThreadsInfo::threads_size() const {
  return threads_.size();
}
inline void ThreadsInfo::clear_threads() {
  threads_.Clear();
}
inline const ::NetworkPacket::ThreadInfo& ThreadsInfo::threads(int index) const {
  // @@protoc_insertion_point(field_get:NetworkPacket.ThreadsInfo.threads)
  return threads_.Get(index);
}
inline ::NetworkPacket::ThreadInfo* ThreadsInfo::mutable_threads(int index) {
  // @@protoc_insertion_point(field_mutable:NetworkPacket.ThreadsInfo.threads)
  return threads_.Mutable(index);
}
inline ::NetworkPacket::ThreadInfo* ThreadsInfo::add_threads() {
  // @@protoc_insertion_point(field_add:NetworkPacket.ThreadsInfo.threads)
  return threads_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::NetworkPacket::ThreadInfo >*
ThreadsInfo::mutable_threads() {
  // @@protoc_insertion_point(field_mutable_list:NetworkPacket.ThreadsInfo.threads)
  return &threads_;
}
inline const ::google::protobuf::RepeatedPtrField< ::NetworkPacket::ThreadInfo >&
ThreadsInfo::threads() const {
  // @@protoc_insertion_point(field_list:NetworkPacket.ThreadsInfo.threads)
  return threads_;
}

// -------------------------------------------------------------------

// LogStringInfo

// required .NetworkPacket.UID uid = 1;
inline bool LogStringInfo::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogStringInfo::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogStringInfo::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogStringInfo::clear_uid() {
  if (uid_ != NULL) uid_->::NetworkPacket::UID::Clear();
  clear_has_uid();
}
inline const ::NetworkPacket::UID& LogStringInfo::uid() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.LogStringInfo.uid)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return uid_ != NULL ? *uid_ : *default_instance().uid_;
#else
  return uid_ != NULL ? *uid_ : *default_instance_->uid_;
#endif
}
inline ::NetworkPacket::UID* LogStringInfo::mutable_uid() {
  set_has_uid();
  if (uid_ == NULL) {
    uid_ = new ::NetworkPacket::UID;
  }
  // @@protoc_insertion_point(field_mutable:NetworkPacket.LogStringInfo.uid)
  return uid_;
}
inline ::NetworkPacket::UID* LogStringInfo::release_uid() {
  // @@protoc_insertion_point(field_release:NetworkPacket.LogStringInfo.uid)
  clear_has_uid();
  ::NetworkPacket::UID* temp = uid_;
  uid_ = NULL;
  return temp;
}
inline void LogStringInfo::set_allocated_uid(::NetworkPacket::UID* uid) {
  delete uid_;
  uid_ = uid;
  if (uid) {
    set_has_uid();
  } else {
    clear_has_uid();
  }
  // @@protoc_insertion_point(field_set_allocated:NetworkPacket.LogStringInfo.uid)
}

// required bool has_compressed = 2;
inline bool LogStringInfo::has_has_compressed() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LogStringInfo::set_has_has_compressed() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LogStringInfo::clear_has_has_compressed() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LogStringInfo::clear_has_compressed() {
  has_compressed_ = false;
  clear_has_has_compressed();
}
inline bool LogStringInfo::has_compressed() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.LogStringInfo.has_compressed)
  return has_compressed_;
}
inline void LogStringInfo::set_has_compressed(bool value) {
  set_has_has_compressed();
  has_compressed_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.LogStringInfo.has_compressed)
}

// required bytes log = 3;
inline bool LogStringInfo::has_log() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LogStringInfo::set_has_log() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LogStringInfo::clear_has_log() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LogStringInfo::clear_log() {
  log_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_log();
}
inline const ::std::string& LogStringInfo::log() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.LogStringInfo.log)
  return log_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogStringInfo::set_log(const ::std::string& value) {
  set_has_log();
  log_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NetworkPacket.LogStringInfo.log)
}
inline void LogStringInfo::set_log(const char* value) {
  set_has_log();
  log_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NetworkPacket.LogStringInfo.log)
}
inline void LogStringInfo::set_log(const void* value, size_t size) {
  set_has_log();
  log_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NetworkPacket.LogStringInfo.log)
}
inline ::std::string* LogStringInfo::mutable_log() {
  set_has_log();
  // @@protoc_insertion_point(field_mutable:NetworkPacket.LogStringInfo.log)
  return log_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogStringInfo::release_log() {
  // @@protoc_insertion_point(field_release:NetworkPacket.LogStringInfo.log)
  clear_has_log();
  return log_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogStringInfo::set_allocated_log(::std::string* log) {
  if (log != NULL) {
    set_has_log();
  } else {
    clear_has_log();
  }
  log_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), log);
  // @@protoc_insertion_point(field_set_allocated:NetworkPacket.LogStringInfo.log)
}

// -------------------------------------------------------------------

// TextureResInfo

// required string res_name = 1;
inline bool TextureResInfo::has_res_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TextureResInfo::set_has_res_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TextureResInfo::clear_has_res_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TextureResInfo::clear_res_name() {
  res_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_res_name();
}
inline const ::std::string& TextureResInfo::res_name() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.TextureResInfo.res_name)
  return res_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TextureResInfo::set_res_name(const ::std::string& value) {
  set_has_res_name();
  res_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NetworkPacket.TextureResInfo.res_name)
}
inline void TextureResInfo::set_res_name(const char* value) {
  set_has_res_name();
  res_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NetworkPacket.TextureResInfo.res_name)
}
inline void TextureResInfo::set_res_name(const char* value, size_t size) {
  set_has_res_name();
  res_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NetworkPacket.TextureResInfo.res_name)
}
inline ::std::string* TextureResInfo::mutable_res_name() {
  set_has_res_name();
  // @@protoc_insertion_point(field_mutable:NetworkPacket.TextureResInfo.res_name)
  return res_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TextureResInfo::release_res_name() {
  // @@protoc_insertion_point(field_release:NetworkPacket.TextureResInfo.res_name)
  clear_has_res_name();
  return res_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TextureResInfo::set_allocated_res_name(::std::string* res_name) {
  if (res_name != NULL) {
    set_has_res_name();
  } else {
    clear_has_res_name();
  }
  res_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), res_name);
  // @@protoc_insertion_point(field_set_allocated:NetworkPacket.TextureResInfo.res_name)
}

// required .NetworkPacket.TextureType type = 2;
inline bool TextureResInfo::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TextureResInfo::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TextureResInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TextureResInfo::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::NetworkPacket::TextureType TextureResInfo::type() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.TextureResInfo.type)
  return static_cast< ::NetworkPacket::TextureType >(type_);
}
inline void TextureResInfo::set_type(::NetworkPacket::TextureType value) {
  assert(::NetworkPacket::TextureType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.TextureResInfo.type)
}

// required uint32 res_id = 3;
inline bool TextureResInfo::has_res_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TextureResInfo::set_has_res_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TextureResInfo::clear_has_res_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TextureResInfo::clear_res_id() {
  res_id_ = 0u;
  clear_has_res_id();
}
inline ::google::protobuf::uint32 TextureResInfo::res_id() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.TextureResInfo.res_id)
  return res_id_;
}
inline void TextureResInfo::set_res_id(::google::protobuf::uint32 value) {
  set_has_res_id();
  res_id_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.TextureResInfo.res_id)
}

// required uint32 width = 4;
inline bool TextureResInfo::has_width() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TextureResInfo::set_has_width() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TextureResInfo::clear_has_width() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TextureResInfo::clear_width() {
  width_ = 0u;
  clear_has_width();
}
inline ::google::protobuf::uint32 TextureResInfo::width() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.TextureResInfo.width)
  return width_;
}
inline void TextureResInfo::set_width(::google::protobuf::uint32 value) {
  set_has_width();
  width_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.TextureResInfo.width)
}

// required uint32 height = 5;
inline bool TextureResInfo::has_height() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TextureResInfo::set_has_height() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TextureResInfo::clear_has_height() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TextureResInfo::clear_height() {
  height_ = 0u;
  clear_has_height();
}
inline ::google::protobuf::uint32 TextureResInfo::height() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.TextureResInfo.height)
  return height_;
}
inline void TextureResInfo::set_height(::google::protobuf::uint32 value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.TextureResInfo.height)
}

// required uint32 mipmaps = 6;
inline bool TextureResInfo::has_mipmaps() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TextureResInfo::set_has_mipmaps() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TextureResInfo::clear_has_mipmaps() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TextureResInfo::clear_mipmaps() {
  mipmaps_ = 0u;
  clear_has_mipmaps();
}
inline ::google::protobuf::uint32 TextureResInfo::mipmaps() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.TextureResInfo.mipmaps)
  return mipmaps_;
}
inline void TextureResInfo::set_mipmaps(::google::protobuf::uint32 value) {
  set_has_mipmaps();
  mipmaps_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.TextureResInfo.mipmaps)
}

// required uint32 size_in_bytes = 7;
inline bool TextureResInfo::has_size_in_bytes() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TextureResInfo::set_has_size_in_bytes() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TextureResInfo::clear_has_size_in_bytes() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TextureResInfo::clear_size_in_bytes() {
  size_in_bytes_ = 0u;
  clear_has_size_in_bytes();
}
inline ::google::protobuf::uint32 TextureResInfo::size_in_bytes() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.TextureResInfo.size_in_bytes)
  return size_in_bytes_;
}
inline void TextureResInfo::set_size_in_bytes(::google::protobuf::uint32 value) {
  set_has_size_in_bytes();
  size_in_bytes_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.TextureResInfo.size_in_bytes)
}

// required uint32 pixel_format = 8;
inline bool TextureResInfo::has_pixel_format() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TextureResInfo::set_has_pixel_format() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TextureResInfo::clear_has_pixel_format() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TextureResInfo::clear_pixel_format() {
  pixel_format_ = 0u;
  clear_has_pixel_format();
}
inline ::google::protobuf::uint32 TextureResInfo::pixel_format() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.TextureResInfo.pixel_format)
  return pixel_format_;
}
inline void TextureResInfo::set_pixel_format(::google::protobuf::uint32 value) {
  set_has_pixel_format();
  pixel_format_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.TextureResInfo.pixel_format)
}

// required .NetworkPacket.SamplerType sampler_filter_type = 9;
inline bool TextureResInfo::has_sampler_filter_type() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TextureResInfo::set_has_sampler_filter_type() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TextureResInfo::clear_has_sampler_filter_type() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TextureResInfo::clear_sampler_filter_type() {
  sampler_filter_type_ = 1;
  clear_has_sampler_filter_type();
}
inline ::NetworkPacket::SamplerType TextureResInfo::sampler_filter_type() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.TextureResInfo.sampler_filter_type)
  return static_cast< ::NetworkPacket::SamplerType >(sampler_filter_type_);
}
inline void TextureResInfo::set_sampler_filter_type(::NetworkPacket::SamplerType value) {
  assert(::NetworkPacket::SamplerType_IsValid(value));
  set_has_sampler_filter_type();
  sampler_filter_type_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.TextureResInfo.sampler_filter_type)
}

// -------------------------------------------------------------------

// TextureChangeSamplerFilter

// required uint32 res_id = 1;
inline bool TextureChangeSamplerFilter::has_res_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TextureChangeSamplerFilter::set_has_res_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TextureChangeSamplerFilter::clear_has_res_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TextureChangeSamplerFilter::clear_res_id() {
  res_id_ = 0u;
  clear_has_res_id();
}
inline ::google::protobuf::uint32 TextureChangeSamplerFilter::res_id() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.TextureChangeSamplerFilter.res_id)
  return res_id_;
}
inline void TextureChangeSamplerFilter::set_res_id(::google::protobuf::uint32 value) {
  set_has_res_id();
  res_id_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.TextureChangeSamplerFilter.res_id)
}

// required .NetworkPacket.SamplerType sampler_filter_type = 2;
inline bool TextureChangeSamplerFilter::has_sampler_filter_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TextureChangeSamplerFilter::set_has_sampler_filter_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TextureChangeSamplerFilter::clear_has_sampler_filter_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TextureChangeSamplerFilter::clear_sampler_filter_type() {
  sampler_filter_type_ = 1;
  clear_has_sampler_filter_type();
}
inline ::NetworkPacket::SamplerType TextureChangeSamplerFilter::sampler_filter_type() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.TextureChangeSamplerFilter.sampler_filter_type)
  return static_cast< ::NetworkPacket::SamplerType >(sampler_filter_type_);
}
inline void TextureChangeSamplerFilter::set_sampler_filter_type(::NetworkPacket::SamplerType value) {
  assert(::NetworkPacket::SamplerType_IsValid(value));
  set_has_sampler_filter_type();
  sampler_filter_type_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.TextureChangeSamplerFilter.sampler_filter_type)
}

// -------------------------------------------------------------------

// DeviceTexResources

// required .NetworkPacket.UID uid = 1;
inline bool DeviceTexResources::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceTexResources::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeviceTexResources::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeviceTexResources::clear_uid() {
  if (uid_ != NULL) uid_->::NetworkPacket::UID::Clear();
  clear_has_uid();
}
inline const ::NetworkPacket::UID& DeviceTexResources::uid() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.DeviceTexResources.uid)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return uid_ != NULL ? *uid_ : *default_instance().uid_;
#else
  return uid_ != NULL ? *uid_ : *default_instance_->uid_;
#endif
}
inline ::NetworkPacket::UID* DeviceTexResources::mutable_uid() {
  set_has_uid();
  if (uid_ == NULL) {
    uid_ = new ::NetworkPacket::UID;
  }
  // @@protoc_insertion_point(field_mutable:NetworkPacket.DeviceTexResources.uid)
  return uid_;
}
inline ::NetworkPacket::UID* DeviceTexResources::release_uid() {
  // @@protoc_insertion_point(field_release:NetworkPacket.DeviceTexResources.uid)
  clear_has_uid();
  ::NetworkPacket::UID* temp = uid_;
  uid_ = NULL;
  return temp;
}
inline void DeviceTexResources::set_allocated_uid(::NetworkPacket::UID* uid) {
  delete uid_;
  uid_ = uid;
  if (uid) {
    set_has_uid();
  } else {
    clear_has_uid();
  }
  // @@protoc_insertion_point(field_set_allocated:NetworkPacket.DeviceTexResources.uid)
}

// repeated .NetworkPacket.TextureResInfo textures = 2;
inline int DeviceTexResources::textures_size() const {
  return textures_.size();
}
inline void DeviceTexResources::clear_textures() {
  textures_.Clear();
}
inline const ::NetworkPacket::TextureResInfo& DeviceTexResources::textures(int index) const {
  // @@protoc_insertion_point(field_get:NetworkPacket.DeviceTexResources.textures)
  return textures_.Get(index);
}
inline ::NetworkPacket::TextureResInfo* DeviceTexResources::mutable_textures(int index) {
  // @@protoc_insertion_point(field_mutable:NetworkPacket.DeviceTexResources.textures)
  return textures_.Mutable(index);
}
inline ::NetworkPacket::TextureResInfo* DeviceTexResources::add_textures() {
  // @@protoc_insertion_point(field_add:NetworkPacket.DeviceTexResources.textures)
  return textures_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::NetworkPacket::TextureResInfo >*
DeviceTexResources::mutable_textures() {
  // @@protoc_insertion_point(field_mutable_list:NetworkPacket.DeviceTexResources.textures)
  return &textures_;
}
inline const ::google::protobuf::RepeatedPtrField< ::NetworkPacket::TextureResInfo >&
DeviceTexResources::textures() const {
  // @@protoc_insertion_point(field_list:NetworkPacket.DeviceTexResources.textures)
  return textures_;
}

// -------------------------------------------------------------------

// DeviceMemResInfo

// required string file_name = 1;
inline bool DeviceMemResInfo::has_file_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceMemResInfo::set_has_file_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeviceMemResInfo::clear_has_file_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeviceMemResInfo::clear_file_name() {
  file_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_file_name();
}
inline const ::std::string& DeviceMemResInfo::file_name() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.DeviceMemResInfo.file_name)
  return file_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceMemResInfo::set_file_name(const ::std::string& value) {
  set_has_file_name();
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NetworkPacket.DeviceMemResInfo.file_name)
}
inline void DeviceMemResInfo::set_file_name(const char* value) {
  set_has_file_name();
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NetworkPacket.DeviceMemResInfo.file_name)
}
inline void DeviceMemResInfo::set_file_name(const char* value, size_t size) {
  set_has_file_name();
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NetworkPacket.DeviceMemResInfo.file_name)
}
inline ::std::string* DeviceMemResInfo::mutable_file_name() {
  set_has_file_name();
  // @@protoc_insertion_point(field_mutable:NetworkPacket.DeviceMemResInfo.file_name)
  return file_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeviceMemResInfo::release_file_name() {
  // @@protoc_insertion_point(field_release:NetworkPacket.DeviceMemResInfo.file_name)
  clear_has_file_name();
  return file_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceMemResInfo::set_allocated_file_name(::std::string* file_name) {
  if (file_name != NULL) {
    set_has_file_name();
  } else {
    clear_has_file_name();
  }
  file_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), file_name);
  // @@protoc_insertion_point(field_set_allocated:NetworkPacket.DeviceMemResInfo.file_name)
}

// required uint32 line_number = 2;
inline bool DeviceMemResInfo::has_line_number() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeviceMemResInfo::set_has_line_number() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DeviceMemResInfo::clear_has_line_number() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DeviceMemResInfo::clear_line_number() {
  line_number_ = 0u;
  clear_has_line_number();
}
inline ::google::protobuf::uint32 DeviceMemResInfo::line_number() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.DeviceMemResInfo.line_number)
  return line_number_;
}
inline void DeviceMemResInfo::set_line_number(::google::protobuf::uint32 value) {
  set_has_line_number();
  line_number_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.DeviceMemResInfo.line_number)
}

// required uint32 size_in_bytes = 3;
inline bool DeviceMemResInfo::has_size_in_bytes() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DeviceMemResInfo::set_has_size_in_bytes() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DeviceMemResInfo::clear_has_size_in_bytes() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DeviceMemResInfo::clear_size_in_bytes() {
  size_in_bytes_ = 0u;
  clear_has_size_in_bytes();
}
inline ::google::protobuf::uint32 DeviceMemResInfo::size_in_bytes() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.DeviceMemResInfo.size_in_bytes)
  return size_in_bytes_;
}
inline void DeviceMemResInfo::set_size_in_bytes(::google::protobuf::uint32 value) {
  set_has_size_in_bytes();
  size_in_bytes_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.DeviceMemResInfo.size_in_bytes)
}

// optional uint32 number = 4;
inline bool DeviceMemResInfo::has_number() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DeviceMemResInfo::set_has_number() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DeviceMemResInfo::clear_has_number() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DeviceMemResInfo::clear_number() {
  number_ = 0u;
  clear_has_number();
}
inline ::google::protobuf::uint32 DeviceMemResInfo::number() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.DeviceMemResInfo.number)
  return number_;
}
inline void DeviceMemResInfo::set_number(::google::protobuf::uint32 value) {
  set_has_number();
  number_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.DeviceMemResInfo.number)
}

// -------------------------------------------------------------------

// DeviceMemResources

// optional .NetworkPacket.UID uid = 1;
inline bool DeviceMemResources::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceMemResources::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeviceMemResources::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeviceMemResources::clear_uid() {
  if (uid_ != NULL) uid_->::NetworkPacket::UID::Clear();
  clear_has_uid();
}
inline const ::NetworkPacket::UID& DeviceMemResources::uid() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.DeviceMemResources.uid)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return uid_ != NULL ? *uid_ : *default_instance().uid_;
#else
  return uid_ != NULL ? *uid_ : *default_instance_->uid_;
#endif
}
inline ::NetworkPacket::UID* DeviceMemResources::mutable_uid() {
  set_has_uid();
  if (uid_ == NULL) {
    uid_ = new ::NetworkPacket::UID;
  }
  // @@protoc_insertion_point(field_mutable:NetworkPacket.DeviceMemResources.uid)
  return uid_;
}
inline ::NetworkPacket::UID* DeviceMemResources::release_uid() {
  // @@protoc_insertion_point(field_release:NetworkPacket.DeviceMemResources.uid)
  clear_has_uid();
  ::NetworkPacket::UID* temp = uid_;
  uid_ = NULL;
  return temp;
}
inline void DeviceMemResources::set_allocated_uid(::NetworkPacket::UID* uid) {
  delete uid_;
  uid_ = uid;
  if (uid) {
    set_has_uid();
  } else {
    clear_has_uid();
  }
  // @@protoc_insertion_point(field_set_allocated:NetworkPacket.DeviceMemResources.uid)
}

// optional uint32 min_size = 2;
inline bool DeviceMemResources::has_min_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeviceMemResources::set_has_min_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DeviceMemResources::clear_has_min_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DeviceMemResources::clear_min_size() {
  min_size_ = 0u;
  clear_has_min_size();
}
inline ::google::protobuf::uint32 DeviceMemResources::min_size() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.DeviceMemResources.min_size)
  return min_size_;
}
inline void DeviceMemResources::set_min_size(::google::protobuf::uint32 value) {
  set_has_min_size();
  min_size_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.DeviceMemResources.min_size)
}

// optional uint32 total_alloc_size = 3;
inline bool DeviceMemResources::has_total_alloc_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DeviceMemResources::set_has_total_alloc_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DeviceMemResources::clear_has_total_alloc_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DeviceMemResources::clear_total_alloc_size() {
  total_alloc_size_ = 0u;
  clear_has_total_alloc_size();
}
inline ::google::protobuf::uint32 DeviceMemResources::total_alloc_size() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.DeviceMemResources.total_alloc_size)
  return total_alloc_size_;
}
inline void DeviceMemResources::set_total_alloc_size(::google::protobuf::uint32 value) {
  set_has_total_alloc_size();
  total_alloc_size_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.DeviceMemResources.total_alloc_size)
}

// optional uint32 total_alloc_number = 4;
inline bool DeviceMemResources::has_total_alloc_number() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DeviceMemResources::set_has_total_alloc_number() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DeviceMemResources::clear_has_total_alloc_number() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DeviceMemResources::clear_total_alloc_number() {
  total_alloc_number_ = 0u;
  clear_has_total_alloc_number();
}
inline ::google::protobuf::uint32 DeviceMemResources::total_alloc_number() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.DeviceMemResources.total_alloc_number)
  return total_alloc_number_;
}
inline void DeviceMemResources::set_total_alloc_number(::google::protobuf::uint32 value) {
  set_has_total_alloc_number();
  total_alloc_number_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.DeviceMemResources.total_alloc_number)
}

// repeated .NetworkPacket.DeviceMemResInfo resources = 5;
inline int DeviceMemResources::resources_size() const {
  return resources_.size();
}
inline void DeviceMemResources::clear_resources() {
  resources_.Clear();
}
inline const ::NetworkPacket::DeviceMemResInfo& DeviceMemResources::resources(int index) const {
  // @@protoc_insertion_point(field_get:NetworkPacket.DeviceMemResources.resources)
  return resources_.Get(index);
}
inline ::NetworkPacket::DeviceMemResInfo* DeviceMemResources::mutable_resources(int index) {
  // @@protoc_insertion_point(field_mutable:NetworkPacket.DeviceMemResources.resources)
  return resources_.Mutable(index);
}
inline ::NetworkPacket::DeviceMemResInfo* DeviceMemResources::add_resources() {
  // @@protoc_insertion_point(field_add:NetworkPacket.DeviceMemResources.resources)
  return resources_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::NetworkPacket::DeviceMemResInfo >*
DeviceMemResources::mutable_resources() {
  // @@protoc_insertion_point(field_mutable_list:NetworkPacket.DeviceMemResources.resources)
  return &resources_;
}
inline const ::google::protobuf::RepeatedPtrField< ::NetworkPacket::DeviceMemResInfo >&
DeviceMemResources::resources() const {
  // @@protoc_insertion_point(field_list:NetworkPacket.DeviceMemResources.resources)
  return resources_;
}

// -------------------------------------------------------------------

// ShaderResInfo

// required string name = 1;
inline bool ShaderResInfo::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShaderResInfo::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShaderResInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShaderResInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& ShaderResInfo::name() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.ShaderResInfo.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ShaderResInfo::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NetworkPacket.ShaderResInfo.name)
}
inline void ShaderResInfo::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NetworkPacket.ShaderResInfo.name)
}
inline void ShaderResInfo::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NetworkPacket.ShaderResInfo.name)
}
inline ::std::string* ShaderResInfo::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:NetworkPacket.ShaderResInfo.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ShaderResInfo::release_name() {
  // @@protoc_insertion_point(field_release:NetworkPacket.ShaderResInfo.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ShaderResInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:NetworkPacket.ShaderResInfo.name)
}

// required uint32 key = 2;
inline bool ShaderResInfo::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShaderResInfo::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShaderResInfo::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShaderResInfo::clear_key() {
  key_ = 0u;
  clear_has_key();
}
inline ::google::protobuf::uint32 ShaderResInfo::key() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.ShaderResInfo.key)
  return key_;
}
inline void ShaderResInfo::set_key(::google::protobuf::uint32 value) {
  set_has_key();
  key_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.ShaderResInfo.key)
}

// required string vs_code = 3;
inline bool ShaderResInfo::has_vs_code() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ShaderResInfo::set_has_vs_code() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ShaderResInfo::clear_has_vs_code() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ShaderResInfo::clear_vs_code() {
  vs_code_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_vs_code();
}
inline const ::std::string& ShaderResInfo::vs_code() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.ShaderResInfo.vs_code)
  return vs_code_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ShaderResInfo::set_vs_code(const ::std::string& value) {
  set_has_vs_code();
  vs_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NetworkPacket.ShaderResInfo.vs_code)
}
inline void ShaderResInfo::set_vs_code(const char* value) {
  set_has_vs_code();
  vs_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NetworkPacket.ShaderResInfo.vs_code)
}
inline void ShaderResInfo::set_vs_code(const char* value, size_t size) {
  set_has_vs_code();
  vs_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NetworkPacket.ShaderResInfo.vs_code)
}
inline ::std::string* ShaderResInfo::mutable_vs_code() {
  set_has_vs_code();
  // @@protoc_insertion_point(field_mutable:NetworkPacket.ShaderResInfo.vs_code)
  return vs_code_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ShaderResInfo::release_vs_code() {
  // @@protoc_insertion_point(field_release:NetworkPacket.ShaderResInfo.vs_code)
  clear_has_vs_code();
  return vs_code_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ShaderResInfo::set_allocated_vs_code(::std::string* vs_code) {
  if (vs_code != NULL) {
    set_has_vs_code();
  } else {
    clear_has_vs_code();
  }
  vs_code_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), vs_code);
  // @@protoc_insertion_point(field_set_allocated:NetworkPacket.ShaderResInfo.vs_code)
}

// required string ps_code = 4;
inline bool ShaderResInfo::has_ps_code() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ShaderResInfo::set_has_ps_code() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ShaderResInfo::clear_has_ps_code() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ShaderResInfo::clear_ps_code() {
  ps_code_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ps_code();
}
inline const ::std::string& ShaderResInfo::ps_code() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.ShaderResInfo.ps_code)
  return ps_code_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ShaderResInfo::set_ps_code(const ::std::string& value) {
  set_has_ps_code();
  ps_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NetworkPacket.ShaderResInfo.ps_code)
}
inline void ShaderResInfo::set_ps_code(const char* value) {
  set_has_ps_code();
  ps_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NetworkPacket.ShaderResInfo.ps_code)
}
inline void ShaderResInfo::set_ps_code(const char* value, size_t size) {
  set_has_ps_code();
  ps_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NetworkPacket.ShaderResInfo.ps_code)
}
inline ::std::string* ShaderResInfo::mutable_ps_code() {
  set_has_ps_code();
  // @@protoc_insertion_point(field_mutable:NetworkPacket.ShaderResInfo.ps_code)
  return ps_code_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ShaderResInfo::release_ps_code() {
  // @@protoc_insertion_point(field_release:NetworkPacket.ShaderResInfo.ps_code)
  clear_has_ps_code();
  return ps_code_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ShaderResInfo::set_allocated_ps_code(::std::string* ps_code) {
  if (ps_code != NULL) {
    set_has_ps_code();
  } else {
    clear_has_ps_code();
  }
  ps_code_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ps_code);
  // @@protoc_insertion_point(field_set_allocated:NetworkPacket.ShaderResInfo.ps_code)
}

// -------------------------------------------------------------------

// DeviceShaderResources

// required .NetworkPacket.UID uid = 1;
inline bool DeviceShaderResources::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceShaderResources::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeviceShaderResources::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeviceShaderResources::clear_uid() {
  if (uid_ != NULL) uid_->::NetworkPacket::UID::Clear();
  clear_has_uid();
}
inline const ::NetworkPacket::UID& DeviceShaderResources::uid() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.DeviceShaderResources.uid)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return uid_ != NULL ? *uid_ : *default_instance().uid_;
#else
  return uid_ != NULL ? *uid_ : *default_instance_->uid_;
#endif
}
inline ::NetworkPacket::UID* DeviceShaderResources::mutable_uid() {
  set_has_uid();
  if (uid_ == NULL) {
    uid_ = new ::NetworkPacket::UID;
  }
  // @@protoc_insertion_point(field_mutable:NetworkPacket.DeviceShaderResources.uid)
  return uid_;
}
inline ::NetworkPacket::UID* DeviceShaderResources::release_uid() {
  // @@protoc_insertion_point(field_release:NetworkPacket.DeviceShaderResources.uid)
  clear_has_uid();
  ::NetworkPacket::UID* temp = uid_;
  uid_ = NULL;
  return temp;
}
inline void DeviceShaderResources::set_allocated_uid(::NetworkPacket::UID* uid) {
  delete uid_;
  uid_ = uid;
  if (uid) {
    set_has_uid();
  } else {
    clear_has_uid();
  }
  // @@protoc_insertion_point(field_set_allocated:NetworkPacket.DeviceShaderResources.uid)
}

// repeated .NetworkPacket.ShaderResInfo shaders = 2;
inline int DeviceShaderResources::shaders_size() const {
  return shaders_.size();
}
inline void DeviceShaderResources::clear_shaders() {
  shaders_.Clear();
}
inline const ::NetworkPacket::ShaderResInfo& DeviceShaderResources::shaders(int index) const {
  // @@protoc_insertion_point(field_get:NetworkPacket.DeviceShaderResources.shaders)
  return shaders_.Get(index);
}
inline ::NetworkPacket::ShaderResInfo* DeviceShaderResources::mutable_shaders(int index) {
  // @@protoc_insertion_point(field_mutable:NetworkPacket.DeviceShaderResources.shaders)
  return shaders_.Mutable(index);
}
inline ::NetworkPacket::ShaderResInfo* DeviceShaderResources::add_shaders() {
  // @@protoc_insertion_point(field_add:NetworkPacket.DeviceShaderResources.shaders)
  return shaders_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::NetworkPacket::ShaderResInfo >*
DeviceShaderResources::mutable_shaders() {
  // @@protoc_insertion_point(field_mutable_list:NetworkPacket.DeviceShaderResources.shaders)
  return &shaders_;
}
inline const ::google::protobuf::RepeatedPtrField< ::NetworkPacket::ShaderResInfo >&
DeviceShaderResources::shaders() const {
  // @@protoc_insertion_point(field_list:NetworkPacket.DeviceShaderResources.shaders)
  return shaders_;
}

// -------------------------------------------------------------------

// GUIResInfo

// required string gui_controls = 1;
inline bool GUIResInfo::has_gui_controls() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GUIResInfo::set_has_gui_controls() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GUIResInfo::clear_has_gui_controls() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GUIResInfo::clear_gui_controls() {
  gui_controls_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_gui_controls();
}
inline const ::std::string& GUIResInfo::gui_controls() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.GUIResInfo.gui_controls)
  return gui_controls_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GUIResInfo::set_gui_controls(const ::std::string& value) {
  set_has_gui_controls();
  gui_controls_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NetworkPacket.GUIResInfo.gui_controls)
}
inline void GUIResInfo::set_gui_controls(const char* value) {
  set_has_gui_controls();
  gui_controls_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NetworkPacket.GUIResInfo.gui_controls)
}
inline void GUIResInfo::set_gui_controls(const char* value, size_t size) {
  set_has_gui_controls();
  gui_controls_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NetworkPacket.GUIResInfo.gui_controls)
}
inline ::std::string* GUIResInfo::mutable_gui_controls() {
  set_has_gui_controls();
  // @@protoc_insertion_point(field_mutable:NetworkPacket.GUIResInfo.gui_controls)
  return gui_controls_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GUIResInfo::release_gui_controls() {
  // @@protoc_insertion_point(field_release:NetworkPacket.GUIResInfo.gui_controls)
  clear_has_gui_controls();
  return gui_controls_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GUIResInfo::set_allocated_gui_controls(::std::string* gui_controls) {
  if (gui_controls != NULL) {
    set_has_gui_controls();
  } else {
    clear_has_gui_controls();
  }
  gui_controls_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), gui_controls);
  // @@protoc_insertion_point(field_set_allocated:NetworkPacket.GUIResInfo.gui_controls)
}

// -------------------------------------------------------------------

// PerformanceInfo

// required .NetworkPacket.UID uid = 1;
inline bool PerformanceInfo::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PerformanceInfo::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PerformanceInfo::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PerformanceInfo::clear_uid() {
  if (uid_ != NULL) uid_->::NetworkPacket::UID::Clear();
  clear_has_uid();
}
inline const ::NetworkPacket::UID& PerformanceInfo::uid() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.PerformanceInfo.uid)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return uid_ != NULL ? *uid_ : *default_instance().uid_;
#else
  return uid_ != NULL ? *uid_ : *default_instance_->uid_;
#endif
}
inline ::NetworkPacket::UID* PerformanceInfo::mutable_uid() {
  set_has_uid();
  if (uid_ == NULL) {
    uid_ = new ::NetworkPacket::UID;
  }
  // @@protoc_insertion_point(field_mutable:NetworkPacket.PerformanceInfo.uid)
  return uid_;
}
inline ::NetworkPacket::UID* PerformanceInfo::release_uid() {
  // @@protoc_insertion_point(field_release:NetworkPacket.PerformanceInfo.uid)
  clear_has_uid();
  ::NetworkPacket::UID* temp = uid_;
  uid_ = NULL;
  return temp;
}
inline void PerformanceInfo::set_allocated_uid(::NetworkPacket::UID* uid) {
  delete uid_;
  uid_ = uid;
  if (uid) {
    set_has_uid();
  } else {
    clear_has_uid();
  }
  // @@protoc_insertion_point(field_set_allocated:NetworkPacket.PerformanceInfo.uid)
}

// required uint64 file_open_count = 2;
inline bool PerformanceInfo::has_file_open_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PerformanceInfo::set_has_file_open_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PerformanceInfo::clear_has_file_open_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PerformanceInfo::clear_file_open_count() {
  file_open_count_ = GOOGLE_ULONGLONG(0);
  clear_has_file_open_count();
}
inline ::google::protobuf::uint64 PerformanceInfo::file_open_count() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.PerformanceInfo.file_open_count)
  return file_open_count_;
}
inline void PerformanceInfo::set_file_open_count(::google::protobuf::uint64 value) {
  set_has_file_open_count();
  file_open_count_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.PerformanceInfo.file_open_count)
}

// required uint64 file_read_count = 3;
inline bool PerformanceInfo::has_file_read_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PerformanceInfo::set_has_file_read_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PerformanceInfo::clear_has_file_read_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PerformanceInfo::clear_file_read_count() {
  file_read_count_ = GOOGLE_ULONGLONG(0);
  clear_has_file_read_count();
}
inline ::google::protobuf::uint64 PerformanceInfo::file_read_count() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.PerformanceInfo.file_read_count)
  return file_read_count_;
}
inline void PerformanceInfo::set_file_read_count(::google::protobuf::uint64 value) {
  set_has_file_read_count();
  file_read_count_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.PerformanceInfo.file_read_count)
}

// required uint64 file_read_bytes = 4;
inline bool PerformanceInfo::has_file_read_bytes() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PerformanceInfo::set_has_file_read_bytes() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PerformanceInfo::clear_has_file_read_bytes() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PerformanceInfo::clear_file_read_bytes() {
  file_read_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_file_read_bytes();
}
inline ::google::protobuf::uint64 PerformanceInfo::file_read_bytes() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.PerformanceInfo.file_read_bytes)
  return file_read_bytes_;
}
inline void PerformanceInfo::set_file_read_bytes(::google::protobuf::uint64 value) {
  set_has_file_read_bytes();
  file_read_bytes_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.PerformanceInfo.file_read_bytes)
}

// required uint64 file_write_count = 5;
inline bool PerformanceInfo::has_file_write_count() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PerformanceInfo::set_has_file_write_count() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PerformanceInfo::clear_has_file_write_count() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PerformanceInfo::clear_file_write_count() {
  file_write_count_ = GOOGLE_ULONGLONG(0);
  clear_has_file_write_count();
}
inline ::google::protobuf::uint64 PerformanceInfo::file_write_count() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.PerformanceInfo.file_write_count)
  return file_write_count_;
}
inline void PerformanceInfo::set_file_write_count(::google::protobuf::uint64 value) {
  set_has_file_write_count();
  file_write_count_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.PerformanceInfo.file_write_count)
}

// required uint64 file_write_bytes = 6;
inline bool PerformanceInfo::has_file_write_bytes() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PerformanceInfo::set_has_file_write_bytes() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PerformanceInfo::clear_has_file_write_bytes() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PerformanceInfo::clear_file_write_bytes() {
  file_write_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_file_write_bytes();
}
inline ::google::protobuf::uint64 PerformanceInfo::file_write_bytes() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.PerformanceInfo.file_write_bytes)
  return file_write_bytes_;
}
inline void PerformanceInfo::set_file_write_bytes(::google::protobuf::uint64 value) {
  set_has_file_write_bytes();
  file_write_bytes_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.PerformanceInfo.file_write_bytes)
}

// required uint64 gl_api_count = 7;
inline bool PerformanceInfo::has_gl_api_count() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PerformanceInfo::set_has_gl_api_count() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PerformanceInfo::clear_has_gl_api_count() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PerformanceInfo::clear_gl_api_count() {
  gl_api_count_ = GOOGLE_ULONGLONG(0);
  clear_has_gl_api_count();
}
inline ::google::protobuf::uint64 PerformanceInfo::gl_api_count() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.PerformanceInfo.gl_api_count)
  return gl_api_count_;
}
inline void PerformanceInfo::set_gl_api_count(::google::protobuf::uint64 value) {
  set_has_gl_api_count();
  gl_api_count_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.PerformanceInfo.gl_api_count)
}

// required uint64 gl_dp_count = 8;
inline bool PerformanceInfo::has_gl_dp_count() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PerformanceInfo::set_has_gl_dp_count() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PerformanceInfo::clear_has_gl_dp_count() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PerformanceInfo::clear_gl_dp_count() {
  gl_dp_count_ = GOOGLE_ULONGLONG(0);
  clear_has_gl_dp_count();
}
inline ::google::protobuf::uint64 PerformanceInfo::gl_dp_count() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.PerformanceInfo.gl_dp_count)
  return gl_dp_count_;
}
inline void PerformanceInfo::set_gl_dp_count(::google::protobuf::uint64 value) {
  set_has_gl_dp_count();
  gl_dp_count_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.PerformanceInfo.gl_dp_count)
}

// required uint64 gl_compressed_tex_count = 9;
inline bool PerformanceInfo::has_gl_compressed_tex_count() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PerformanceInfo::set_has_gl_compressed_tex_count() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PerformanceInfo::clear_has_gl_compressed_tex_count() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PerformanceInfo::clear_gl_compressed_tex_count() {
  gl_compressed_tex_count_ = GOOGLE_ULONGLONG(0);
  clear_has_gl_compressed_tex_count();
}
inline ::google::protobuf::uint64 PerformanceInfo::gl_compressed_tex_count() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.PerformanceInfo.gl_compressed_tex_count)
  return gl_compressed_tex_count_;
}
inline void PerformanceInfo::set_gl_compressed_tex_count(::google::protobuf::uint64 value) {
  set_has_gl_compressed_tex_count();
  gl_compressed_tex_count_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.PerformanceInfo.gl_compressed_tex_count)
}

// required uint64 gl_tex_count = 10;
inline bool PerformanceInfo::has_gl_tex_count() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PerformanceInfo::set_has_gl_tex_count() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PerformanceInfo::clear_has_gl_tex_count() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PerformanceInfo::clear_gl_tex_count() {
  gl_tex_count_ = GOOGLE_ULONGLONG(0);
  clear_has_gl_tex_count();
}
inline ::google::protobuf::uint64 PerformanceInfo::gl_tex_count() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.PerformanceInfo.gl_tex_count)
  return gl_tex_count_;
}
inline void PerformanceInfo::set_gl_tex_count(::google::protobuf::uint64 value) {
  set_has_gl_tex_count();
  gl_tex_count_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.PerformanceInfo.gl_tex_count)
}

// required uint64 gl_tex_bytes = 11;
inline bool PerformanceInfo::has_gl_tex_bytes() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PerformanceInfo::set_has_gl_tex_bytes() {
  _has_bits_[0] |= 0x00000400u;
}
inline void PerformanceInfo::clear_has_gl_tex_bytes() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void PerformanceInfo::clear_gl_tex_bytes() {
  gl_tex_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_gl_tex_bytes();
}
inline ::google::protobuf::uint64 PerformanceInfo::gl_tex_bytes() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.PerformanceInfo.gl_tex_bytes)
  return gl_tex_bytes_;
}
inline void PerformanceInfo::set_gl_tex_bytes(::google::protobuf::uint64 value) {
  set_has_gl_tex_bytes();
  gl_tex_bytes_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.PerformanceInfo.gl_tex_bytes)
}

// -------------------------------------------------------------------

// PerformanceParticlesInfo

// required bool enable = 1;
inline bool PerformanceParticlesInfo::has_enable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PerformanceParticlesInfo::set_has_enable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PerformanceParticlesInfo::clear_has_enable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PerformanceParticlesInfo::clear_enable() {
  enable_ = false;
  clear_has_enable();
}
inline bool PerformanceParticlesInfo::enable() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.PerformanceParticlesInfo.enable)
  return enable_;
}
inline void PerformanceParticlesInfo::set_enable(bool value) {
  set_has_enable();
  enable_ = value;
  // @@protoc_insertion_point(field_set:NetworkPacket.PerformanceParticlesInfo.enable)
}

// -------------------------------------------------------------------

// PerformanceGlobalShaderInfo

// required string name = 1;
inline bool PerformanceGlobalShaderInfo::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PerformanceGlobalShaderInfo::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PerformanceGlobalShaderInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PerformanceGlobalShaderInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& PerformanceGlobalShaderInfo::name() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.PerformanceGlobalShaderInfo.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PerformanceGlobalShaderInfo::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NetworkPacket.PerformanceGlobalShaderInfo.name)
}
inline void PerformanceGlobalShaderInfo::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NetworkPacket.PerformanceGlobalShaderInfo.name)
}
inline void PerformanceGlobalShaderInfo::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NetworkPacket.PerformanceGlobalShaderInfo.name)
}
inline ::std::string* PerformanceGlobalShaderInfo::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:NetworkPacket.PerformanceGlobalShaderInfo.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PerformanceGlobalShaderInfo::release_name() {
  // @@protoc_insertion_point(field_release:NetworkPacket.PerformanceGlobalShaderInfo.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PerformanceGlobalShaderInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:NetworkPacket.PerformanceGlobalShaderInfo.name)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace NetworkPacket

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::NetworkPacket::Constant> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::NetworkPacket::MessageType> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::NetworkPacket::TextureType> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::NetworkPacket::SamplerType> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_NetworkPacket_2eproto__INCLUDED
